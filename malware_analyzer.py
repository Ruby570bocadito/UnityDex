#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Módulo para análisis avanzado de malware
Permite analizar archivos sospechosos, detectar comportamientos maliciosos y generar informes detallados
"""

import os
import sys
import json
import time
import hashlib
import requests
import tempfile
import subprocess
from datetime import datetime

# Importar bibliotecas específicas para análisis de malware
try:
    import magic
    import yara
    import pefile
    import ssdeep
except ImportError:
    print("Error: No se pudieron importar las bibliotecas necesarias para análisis de malware.")
    print("Instale las dependencias con: pip install python-magic yara-python pefile ssdeep")
    sys.exit(1)

# Importar utilidades comunes
try:
    from utils import load_config
except ImportError:
    print("Error: No se pudieron importar las utilidades necesarias.")
    sys.exit(1)

# Configurar logging
import logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger('malware_analyzer')

# Constantes y configuraciones
MALWARE_TYPES = {
    'ransomware': {
        'descripcion': 'Software malicioso que cifra archivos y exige un rescate',
        'indicadores': ['cifrado de archivos', 'notas de rescate', 'eliminación de copias de seguridad'],
        'extensiones_comunes': ['.encrypted', '.locked', '.crypted', '.crypt', '.crypto', '.enc', '.pay', '.wallet']
    },
    'troyano': {
        'descripcion': 'Malware que se disfraza como software legítimo',
        'indicadores': ['conexiones ocultas', 'ejecución persistente', 'robo de credenciales'],
        'familias_comunes': ['Zeus', 'Emotet', 'Trickbot', 'Agent Tesla', 'Formbook']
    },
    'backdoor': {
        'descripcion': 'Proporciona acceso remoto no autorizado al sistema',
        'indicadores': ['puertos abiertos inusuales', 'conexiones salientes persistentes', 'ejecución de comandos remotos'],
        'técnicas_comunes': ['reverse shell', 'conexiones periódicas a C&C', 'evasión de firewall']
    },
    'spyware': {
        'descripcion': 'Software que recopila información sin consentimiento',
        'indicadores': ['captura de pulsaciones de teclas', 'capturas de pantalla', 'acceso a cámara/micrófono'],
        'objetivos_comunes': ['credenciales', 'información financiera', 'comunicaciones', 'hábitos de navegación']
    },
    'rootkit': {
        'descripcion': 'Oculta la presencia de otros malware en el sistema',
        'indicadores': ['ocultación de procesos', 'modificación del kernel', 'interceptación de API del sistema'],
        'niveles': ['nivel de usuario', 'nivel de kernel', 'nivel de hipervisor', 'nivel de firmware']
    },
    'botnet': {
        'descripcion': 'Red de dispositivos infectados controlados remotamente',
        'indicadores': ['tráfico de red anómalo', 'comunicación con servidores C&C', 'actividad sincronizada'],
        'usos_comunes': ['DDoS', 'minería de criptomonedas', 'spam', 'propagación de malware']
    },
    'adware': {
        'descripcion': 'Software que muestra publicidad no deseada',
        'indicadores': ['popups excesivos', 'cambios en el navegador', 'redirecciones web'],
        'comportamientos': ['instalación de barras de herramientas', 'cambio de página de inicio', 'inyección de anuncios']
    },
    'cryptominer': {
        'descripcion': 'Utiliza recursos del sistema para minar criptomonedas',
        'indicadores': ['alto uso de CPU/GPU', 'conexiones a pools de minería', 'procesos ocultos con alto consumo'],
        'criptomonedas_comunes': ['Monero', 'Ethereum', 'Bitcoin', 'Zcash']
    },
    'worm': {
        'descripcion': 'Malware que se propaga automáticamente a otros sistemas',
        'indicadores': ['replicación automática', 'escaneo de red', 'explotación de vulnerabilidades'],
        'vectores_propagación': ['email', 'unidades USB', 'vulnerabilidades de red', 'compartición de archivos']
    },
    'fileless': {
        'descripcion': 'Malware que opera en memoria sin escribir archivos en disco',
        'indicadores': ['scripts en memoria', 'uso de PowerShell/WMI', 'inyección de procesos'],
        'técnicas_evasión': ['inyección de código', 'scripts ofuscados', 'uso de herramientas legítimas']
    }
}

# Reglas YARA básicas para detección de malware
YARA_RULES_TEMPLATE = """
rule generic_ransomware {
    meta:
        description = "Detecta posibles indicadores de ransomware"
        author = "UnityDex Team"
        severity = "high"
    strings:
        $ransom_note1 = "your files have been encrypted" nocase
        $ransom_note2 = "pay the ransom" nocase
        $ransom_note3 = "bitcoin" nocase
        $ransom_note4 = "decrypt your files" nocase
        $ransom_note5 = "payment" nocase
        $file_encryption = {68 A1 ?? ?? ?? ?? 8B ?? 89}
    condition:
        2 of ($ransom_note*) or $file_encryption
}

rule suspicious_behaviors {
    meta:
        description = "Detecta comportamientos sospechosos en ejecutables"
        author = "UnityDex Team"
        severity = "medium"
    strings:
        $anti_vm1 = "vmware" nocase
        $anti_vm2 = "virtualbox" nocase
        $anti_vm3 = "qemu" nocase
        $anti_debug1 = "IsDebuggerPresent"
        $anti_debug2 = "CheckRemoteDebuggerPresent"
        $anti_debug3 = "OutputDebugString"
        $injection1 = "VirtualAllocEx"
        $injection2 = "WriteProcessMemory"
        $injection3 = "CreateRemoteThread"
        $keylogger1 = "GetAsyncKeyState"
        $keylogger2 = "GetKeyboardState"
    condition:
        (any of ($anti_vm*) and any of ($anti_debug*)) or
        all of ($injection*) or
        all of ($keylogger*)
}

rule suspicious_network {
    meta:
        description = "Detecta indicadores de comunicación con C&C"
        author = "UnityDex Team"
        severity = "medium"
    strings:
        $tor = ".onion"
        $ip_regex = /\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d{1,5}/
        $http_req = {48 54 54 50 2F 31 2E 31}
        $dns_req = {00 01 00 00 00 01 00 00}
    condition:
        $tor or $ip_regex or $http_req or $dns_req
}
"""

class MalwareAnalyzer:
    """Analizador avanzado de malware con capacidades de detección de comportamiento,
    técnicas de evasión y análisis mediante redes neuronales"""
    
    def __init__(self, config_file=None):
        """Inicializa el analizador de malware con opciones avanzadas"""
        self.config = load_config(config_file) if config_file else {}
        self.temp_dir = tempfile.mkdtemp(prefix="unitydex_malware_")
        self.yara_rules_file = os.path.join(self.temp_dir, "malware_rules.yar")
        
        # Crear archivo de reglas YARA
        with open(self.yara_rules_file, 'w') as f:
            f.write(YARA_RULES_TEMPLATE)
        
        # Compilar reglas YARA
        try:
            self.rules = yara.compile(filepath=self.yara_rules_file)
            logger.info("Reglas YARA compiladas correctamente")
        except Exception as e:
            logger.error(f"Error al compilar reglas YARA: {e}")
            self.rules = None
            
        # Opciones avanzadas de análisis
        self.sandbox_analysis = self.config.get('sandbox_analysis', False)
        self.memory_analysis = self.config.get('memory_analysis', False)
        self.network_analysis = self.config.get('network_analysis', False)
        self.deep_scan = self.config.get('deep_scan', False)
        self.ai_detection = self.config.get('ai_detection', False)
        self.extract_iocs = self.config.get('extract_iocs', True)
        self.detect_evasion = self.config.get('detect_evasion', True)
        self.detect_obfuscation = self.config.get('detect_obfuscation', True)
        self.detect_persistence = self.config.get('detect_persistence', True)
        self.detect_c2 = self.config.get('detect_c2', True)
        
        # Inicializar modelo de IA si está habilitado
        self.ai_model = None
        if self.ai_detection:
            self._init_ai_model()
            
        logger.info("Analizador avanzado de malware inicializado con opciones extendidas")
    
    def __del__(self):
        """Limpieza al destruir la instancia"""
        try:
            import shutil
            shutil.rmtree(self.temp_dir, ignore_errors=True)
        except:
            pass
    
    def _init_ai_model(self):
        """Inicializa el modelo de IA para detección de malware"""
        try:
            logger.info("Inicializando modelo de IA para detección de malware...")
            
            # En una implementación real, cargaríamos un modelo pre-entrenado
            # Simulamos la carga del modelo
            self.ai_model = {
                'loaded': True,
                'type': 'CNN+LSTM',
                'features': ['opcode_sequences', 'api_calls', 'entropy_map', 'byte_histogram']
            }
            
            logger.info("Modelo de IA para detección de malware inicializado correctamente")
        except Exception as e:
            logger.error(f"Error al inicializar el modelo de IA: {str(e)}")
            self.ai_detection = False
    
    def analyze_behavior(self, file_path):
        """Analiza el comportamiento del malware en un entorno sandbox"""
        if not self.sandbox_analysis:
            logger.info("Análisis de comportamiento deshabilitado")
            return {}
        
        logger.info(f"Iniciando análisis de comportamiento para {file_path}")
        behavior_results = {
            'process_activity': [],
            'file_activity': [],
            'registry_activity': [],
            'network_activity': [],
            'api_calls': [],
            'evasion_attempts': [],
            'persistence_mechanisms': [],
            'summary': {}
        }
        
        try:
            # En una implementación real, se enviaría el archivo a un sandbox
            # como Cuckoo, VMRay, o se utilizaría una VM local con herramientas
            # de monitorización
            
            # Simulamos resultados del análisis de comportamiento
            behavior_results['process_activity'] = [
                {'process': 'malware.exe', 'pid': 1234, 'command_line': 'malware.exe -s', 'parent_pid': 0},
                {'process': 'cmd.exe', 'pid': 1235, 'command_line': 'cmd.exe /c whoami', 'parent_pid': 1234},
                {'process': 'powershell.exe', 'pid': 1236, 'command_line': 'powershell.exe -enc BASE64ENCODEDCOMMAND', 'parent_pid': 1234}
            ]
            
            behavior_results['file_activity'] = [
                {'type': 'create', 'path': 'C:\\Windows\\Temp\\dropper.exe'},
                {'type': 'modify', 'path': 'C:\\Windows\\System32\\drivers\\etc\\hosts'},
                {'type': 'delete', 'path': 'C:\\evidence.txt'}
            ]
            
            behavior_results['registry_activity'] = [
                {'type': 'create', 'key': 'HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run', 'value': 'Malware', 'data': 'C:\\Windows\\Temp\\dropper.exe'},
                {'type': 'modify', 'key': 'HKLM\\SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy', 'value': 'EnableFirewall', 'data': '0'}
            ]
            
            behavior_results['network_activity'] = [
                {'type': 'dns_request', 'domain': 'evil-c2-server.com', 'ip': '192.168.1.100'},
                {'type': 'http_request', 'url': 'http://evil-c2-server.com/gate.php', 'method': 'POST', 'data': 'stolen_data=BASE64ENCODEDDATA'},
                {'type': 'tcp_connection', 'destination_ip': '192.168.1.100', 'destination_port': 8080, 'protocol': 'tcp'}
            ]
            
            # Detectar técnicas de evasión
            if self.detect_evasion:
                evasion_techniques = self._detect_evasion_techniques(behavior_results)
                behavior_results['evasion_attempts'] = evasion_techniques
            
            # Detectar mecanismos de persistencia
            if self.detect_persistence:
                persistence = self._detect_persistence_mechanisms(behavior_results)
                behavior_results['persistence_mechanisms'] = persistence
            
            # Generar resumen
            behavior_results['summary'] = {
                'severity': 'high',
                'confidence': 0.85,
                'techniques': ['process_injection', 'registry_persistence', 'data_exfiltration'],
                'mitre_techniques': ['T1055', 'T1547.001', 'T1567']
            }
            
            logger.info("Análisis de comportamiento completado")
            return behavior_results
            
        except Exception as e:
            logger.error(f"Error durante el análisis de comportamiento: {str(e)}")
            return behavior_results
    
    def analyze_memory(self, file_path):
        """Analiza la memoria del proceso para detectar técnicas avanzadas"""
        if not self.memory_analysis:
            logger.info("Análisis de memoria deshabilitado")
            return {}
        
        logger.info(f"Iniciando análisis de memoria para {file_path}")
        memory_results = {
            'injected_code': [],
            'hidden_processes': [],
            'hooked_functions': [],
            'suspicious_regions': [],
            'strings_in_memory': [],
            'summary': {}
        }
        
        try:
            # En una implementación real, se utilizaría Volatility, WinDbg, o herramientas
            # similares para analizar la memoria del proceso
            
            # Simulamos resultados del análisis de memoria
            memory_results['injected_code'] = [
                {'process': 'explorer.exe', 'region': '0x00400000-0x00410000', 'protection': 'RWX', 'size': 65536},
                {'process': 'svchost.exe', 'region': '0x7FFE0000-0x7FFF0000', 'protection': 'RWX', 'size': 65536}
            ]
            
            memory_results['hidden_processes'] = [
                {'pid': 4567, 'name': 'hidden.exe', 'technique': 'DKOM'}
            ]
            
            memory_results['hooked_functions'] = [
                {'module': 'ntdll.dll', 'function': 'NtCreateFile', 'hook_type': 'IAT'},
                {'module': 'kernel32.dll', 'function': 'CreateProcessA', 'hook_type': 'Inline'}
            ]
            
            memory_results['suspicious_regions'] = [
                {'address': '0x7FFE0000', 'size': 65536, 'entropy': 7.8, 'contains_shellcode': True}
            ]
            
            # Generar resumen
            memory_results['summary'] = {
                'severity': 'critical',
                'confidence': 0.95,
                'techniques': ['process_hollowing', 'api_hooking', 'dkom'],
                'mitre_techniques': ['T1055.012', 'T1179', 'T1014']
            }
            
            logger.info("Análisis de memoria completado")
            return memory_results
            
        except Exception as e:
            logger.error(f"Error durante el análisis de memoria: {str(e)}")
            return memory_results
    
    def analyze_network(self, file_path):
        """Analiza la actividad de red del malware"""
        if not self.network_analysis:
            logger.info("Análisis de red deshabilitado")
            return {}
        
        logger.info(f"Iniciando análisis de red para {file_path}")
        network_results = {
            'dns_requests': [],
            'http_requests': [],
            'connections': [],
            'c2_servers': [],
            'data_exfiltration': [],
            'summary': {}
        }
        
        try:
            # En una implementación real, se analizaría un archivo PCAP o se monitorizaría
            # la actividad de red en tiempo real
            
            # Simulamos resultados del análisis de red
            network_results['dns_requests'] = [
                {'domain': 'evil-c2-server.com', 'type': 'A', 'response': '192.168.1.100'},
                {'domain': 'legit-looking-domain.com', 'type': 'A', 'response': '192.168.1.101'}
            ]
            
            network_results['http_requests'] = [
                {'url': 'http://evil-c2-server.com/gate.php', 'method': 'POST', 'user_agent': 'Mozilla/5.0', 'data_size': 1024, 'response_code': 200},
                {'url': 'https://legit-looking-domain.com/config.json', 'method': 'GET', 'user_agent': 'Mozilla/5.0', 'data_size': 512, 'response_code': 200}
            ]
            
            network_results['connections'] = [
                {'destination_ip': '192.168.1.100', 'destination_port': 8080, 'protocol': 'tcp', 'duration': 120, 'bytes_sent': 4096, 'bytes_received': 2048},
                {'destination_ip': '192.168.1.101', 'destination_port': 443, 'protocol': 'tcp', 'duration': 60, 'bytes_sent': 2048, 'bytes_received': 1024}
            ]
            
            # Detectar servidores C2
            if self.detect_c2:
                c2_servers = self._detect_c2_servers(network_results)
                network_results['c2_servers'] = c2_servers
            
            # Detectar exfiltración de datos
            data_exfil = self._detect_data_exfiltration(network_results)
            network_results['data_exfiltration'] = data_exfil
            
            # Generar resumen
            network_results['summary'] = {
                'severity': 'high',
                'confidence': 0.9,
                'techniques': ['c2_communication', 'data_exfiltration', 'dns_tunneling'],
                'mitre_techniques': ['T1071', 'T1567', 'T1071.004']
            }
            
            logger.info("Análisis de red completado")
            return network_results
            
        except Exception as e:
            logger.error(f"Error durante el análisis de red: {str(e)}")
            return network_results
    
    def extract_iocs(self, file_path, analysis_results):
        """Extrae indicadores de compromiso (IOCs) del archivo y los resultados del análisis"""
        if not self.extract_iocs:
            logger.info("Extracción de IOCs deshabilitada")
            return {}
        
        logger.info(f"Extrayendo IOCs para {file_path}")
        iocs = {
            'ips': [],
            'domains': [],
            'urls': [],
            'emails': [],
            'files': [],
            'registry': [],
            'mutexes': []
        }
        
        try:
            # Extraer IPs, dominios y URLs del análisis estático
            if 'strings' in analysis_results.get('static_analysis', {}):
                strings = analysis_results['static_analysis']['strings']
                
                # Patrones para IOCs
                ip_pattern = re.compile(r'\b(?:\d{1,3}\.){3}\d{1,3}\b')
                domain_pattern = re.compile(r'\b(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}\b')
                url_pattern = re.compile(r'https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+') 
                email_pattern = re.compile(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b')
                
                for string in strings:
                    # Buscar IPs
                    ip_matches = ip_pattern.findall(string)
                    for ip in ip_matches:
                        if ip not in iocs['ips'] and self._is_valid_ip(ip):
                            iocs['ips'].append(ip)
                    
                    # Buscar dominios
                    domain_matches = domain_pattern.findall(string)
                    for domain in domain_matches:
                        if domain not in iocs['domains'] and not self._is_common_domain(domain):
                            iocs['domains'].append(domain)
                    
                    # Buscar URLs
                    url_matches = url_pattern.findall(string)
                    for url in url_matches:
                        if url not in iocs['urls']:
                            iocs['urls'].append(url)
                    
                    # Buscar emails
                    email_matches = email_pattern.findall(string)
                    for email in email_matches:
                        if email not in iocs['emails']:
                            iocs['emails'].append(email)
            
            # Extraer IOCs del análisis de comportamiento
            if 'behavior_analysis' in analysis_results:
                behavior = analysis_results['behavior_analysis']
                
                # Extraer archivos creados/modificados
                if 'file_activity' in behavior:
                    for file_activity in behavior['file_activity']:
                        if file_activity.get('path') and file_activity.get('type') in ['create', 'modify']:
                            if file_activity['path'] not in iocs['files']:
                                iocs['files'].append(file_activity['path'])
                
                # Extraer claves de registro
                if 'registry_activity' in behavior:
                    for reg_activity in behavior['registry_activity']:
                        if reg_activity.get('key') and reg_activity.get('type') in ['create', 'modify']:
                            reg_entry = {
                                'key': reg_activity['key'],
                                'value': reg_activity.get('value', ''),
                                'data': reg_activity.get('data', '')
                            }
                            if reg_entry not in iocs['registry']:
                                iocs['registry'].append(reg_entry)
                
                # Extraer mutexes
                if 'mutexes' in behavior:
                    for mutex in behavior['mutexes']:
                        if mutex not in iocs['mutexes']:
                            iocs['mutexes'].append(mutex)
            
            # Extraer IOCs del análisis de red
            if 'network_analysis' in analysis_results:
                network = analysis_results['network_analysis']
                
                # Extraer IPs y dominios de DNS
                if 'dns_requests' in network:
                    for dns in network['dns_requests']:
                        if dns.get('domain') and dns['domain'] not in iocs['domains']:
                            iocs['domains'].append(dns['domain'])
                        if dns.get('response') and dns['response'] not in iocs['ips'] and self._is_valid_ip(dns['response']):
                            iocs['ips'].append(dns['response'])
                
                # Extraer URLs de HTTP
                if 'http_requests' in network:
                    for http in network['http_requests']:
                        if http.get('url') and http['url'] not in iocs['urls']:
                            iocs['urls'].append(http['url'])
                
                # Extraer IPs de conexiones
                if 'connections' in network:
                    for conn in network['connections']:
                        if conn.get('destination_ip') and conn['destination_ip'] not in iocs['ips'] and self._is_valid_ip(conn['destination_ip']):
                            iocs['ips'].append(conn['destination_ip'])
            
            logger.info(f"Extracción de IOCs completada: {len(iocs['ips'])} IPs, {len(iocs['domains'])} dominios, {len(iocs['urls'])} URLs")
            return iocs
            
        except Exception as e:
            logger.error(f"Error durante la extracción de IOCs: {str(e)}")
            return iocs
    
    def _is_valid_ip(self, ip):
        """Verifica si una IP es válida y no es una IP privada o especial"""
        try:
            # Verificar formato de IP
            parts = ip.split('.')
            if len(parts) != 4:
                return False
            
            for part in parts:
                if not 0 <= int(part) <= 255:
                    return False
            
            # Excluir IPs privadas y especiales
            if ip.startswith(('10.', '172.16.', '172.17.', '172.18.', '172.19.', '172.20.', 
                             '172.21.', '172.22.', '172.23.', '172.24.', '172.25.', '172.26.', 
                             '172.27.', '172.28.', '172.29.', '172.30.', '172.31.', '192.168.')):
                return False
            
            if ip in ['127.0.0.1', '0.0.0.0']:
                return False
            
            return True
        except:
            return False
    
    def _is_common_domain(self, domain):
        """Verifica si un dominio es común y probablemente no malicioso"""
        common_domains = [
            'google.com', 'microsoft.com', 'apple.com', 'amazon.com', 'facebook.com',
            'github.com', 'youtube.com', 'gmail.com', 'yahoo.com', 'hotmail.com',
            'akamai.net', 'cloudfront.net', 'googleapis.com', 'gstatic.com', 'windows.com',
            'live.com', 'office.com', 'msn.com', 'linkedin.com', 'twitter.com'
        ]
        
        for common in common_domains:
            if domain == common or domain.endswith('.' + common):
                return True
        
        return False
    
    def _detect_evasion_techniques(self, behavior_results):
        """Detecta técnicas de evasión en el comportamiento del malware"""
        evasion_techniques = []
        
        # Buscar técnicas de evasión en procesos
        for process in behavior_results.get('process_activity', []):
            # Detectar ofuscación de PowerShell
            if 'powershell.exe' in process.get('process', '').lower() and '-enc' in process.get('command_line', '').lower():
                evasion_techniques.append({
                    'technique': 'powershell_encoding',
                    'description': 'Uso de comandos PowerShell codificados en Base64',
                    'mitre_id': 'T1027.010',
                    'evidence': process.get('command_line', '')
                })
        
        # Buscar técnicas de evasión en actividad de archivos
        for file_activity in behavior_results.get('file_activity', []):
            # Detectar eliminación de evidencias
            if file_activity.get('type') == 'delete' and 'evidence' in file_activity.get('path', '').lower():
                evasion_techniques.append({
                    'technique': 'evidence_removal',
                    'description': 'Eliminación de archivos de evidencia',
                    'mitre_id': 'T1070.004',
                    'evidence': file_activity.get('path', '')
                })
        
        # Buscar técnicas de evasión en actividad de registro
        for reg_activity in behavior_results.get('registry_activity', []):
            # Detectar desactivación de firewall
            if 'firewall' in reg_activity.get('key', '').lower() and reg_activity.get('data') == '0':
                evasion_techniques.append({
                    'technique': 'disable_security_tools',
                    'description': 'Desactivación del firewall de Windows',
                    'mitre_id': 'T1562.004',
                    'evidence': f"{reg_activity.get('key', '')} = {reg_activity.get('data', '')}"
                })
        
        return evasion_techniques
    
    def _detect_persistence_mechanisms(self, behavior_results):
        """Detecta mecanismos de persistencia en el comportamiento del malware"""
        persistence_mechanisms = []
        
        # Buscar mecanismos de persistencia en actividad de registro
        for reg_activity in behavior_results.get('registry_activity', []):
            # Detectar persistencia en Run keys
            if 'run' in reg_activity.get('key', '').lower() and reg_activity.get('type') in ['create', 'modify']:
                persistence_mechanisms.append({
                    'technique': 'registry_run_keys',
                    'description': 'Persistencia mediante claves de registro Run',
                    'mitre_id': 'T1547.001',
                    'evidence': f"{reg_activity.get('key', '')}\\{reg_activity.get('value', '')} = {reg_activity.get('data', '')}"
                })
        
        # Buscar mecanismos de persistencia en actividad de archivos
        startup_folders = ['\\startup\\', '\\start menu\\programs\\startup\\', '\\appdata\\roaming\\microsoft\\windows\\start menu\\programs\\startup\\']
        for file_activity in behavior_results.get('file_activity', []):
            if file_activity.get('type') in ['create', 'modify']:
                path = file_activity.get('path', '').lower()
                for folder in startup_folders:
                    if folder in path:
                        persistence_mechanisms.append({
                            'technique': 'startup_folder',
                            'description': 'Persistencia mediante carpeta de inicio',
                            'mitre_id': 'T1547.001',
                            'evidence': file_activity.get('path', '')
                        })
                        break
        
        return persistence_mechanisms
    
    def _detect_c2_servers(self, network_results):
        """Detecta servidores de comando y control (C2) en la actividad de red"""
        c2_servers = []
        
        # Patrones sospechosos en URLs
        suspicious_patterns = ['gate.php', 'panel.php', 'admin.php', 'config.bin', 'update.bin', '/c2/', '/cmd/', '/gate/']
        
        # Analizar solicitudes HTTP
        for http in network_results.get('http_requests', []):
            url = http.get('url', '').lower()
            
            # Verificar patrones sospechosos
            for pattern in suspicious_patterns:
                if pattern in url:
                    c2_server = {
                        'url': http.get('url'),
                        'ip': self._extract_ip_from_url(http.get('url', '')),
                        'port': self._extract_port_from_url(http.get('url', '')),
                        'protocol': 'http' if url.startswith('http://') else 'https',
                        'confidence': 'high',
                        'evidence': f"URL contiene patrón sospechoso: {pattern}"
                    }
                    c2_servers.append(c2_server)
                    break
            
            # Verificar solicitudes POST con datos
            if http.get('method') == 'POST' and http.get('data_size', 0) > 0:
                c2_server = {
                    'url': http.get('url'),
                    'ip': self._extract_ip_from_url(http.get('url', '')),
                    'port': self._extract_port_from_url(http.get('url', '')),
                    'protocol': 'http' if url.startswith('http://') else 'https',
                    'confidence': 'medium',
                    'evidence': f"Solicitud POST con {http.get('data_size')} bytes de datos"
                }
                c2_servers.append(c2_server)
        
        # Analizar conexiones TCP/UDP inusuales
        for conn in network_results.get('connections', []):
            # Puertos sospechosos no estándar
            suspicious_ports = [4444, 8080, 1080, 31337, 1337, 9001, 9002, 2222]
            
            if conn.get('destination_port') in suspicious_ports:
                c2_server = {
                    'ip': conn.get('destination_ip'),
                    'port': conn.get('destination_port'),
                    'protocol': conn.get('protocol', 'tcp'),
                    'confidence': 'medium',
                    'evidence': f"Conexión a puerto sospechoso: {conn.get('destination_port')}"
                }
                c2_servers.append(c2_server)
            
            # Conexiones de larga duración con transferencia de datos
            if conn.get('duration', 0) > 300 and conn.get('bytes_sent', 0) > 10000:
                c2_server = {
                    'ip': conn.get('destination_ip'),
                    'port': conn.get('destination_port'),
                    'protocol': conn.get('protocol', 'tcp'),
                    'confidence': 'medium',
                    'evidence': f"Conexión de larga duración ({conn.get('duration')}s) con transferencia de datos ({conn.get('bytes_sent')} bytes enviados)"
                }
                c2_servers.append(c2_server)
        
        return c2_servers
    
    def _detect_data_exfiltration(self, network_results):
        """Detecta posible exfiltración de datos en la actividad de red"""
        data_exfiltration = []
        
        # Analizar solicitudes HTTP
        for http in network_results.get('http_requests', []):
            # Solicitudes POST con grandes cantidades de datos
            if http.get('method') == 'POST' and http.get('data_size', 0) > 10000:
                exfil = {
                    'destination': http.get('url'),
                    'protocol': 'http/https',
                    'size': http.get('data_size'),
                    'confidence': 'high',
                    'evidence': f"Solicitud POST con {http.get('data_size')} bytes de datos"
                }
                data_exfiltration.append(exfil)
        
        # Analizar conexiones TCP/UDP
        for conn in network_results.get('connections', []):
            # Conexiones con grandes cantidades de datos enviados
            if conn.get('bytes_sent', 0) > 100000:
                exfil = {
                    'destination': f"{conn.get('destination_ip')}:{conn.get('destination_port')}",
                    'protocol': conn.get('protocol', 'tcp'),
                    'size': conn.get('bytes_sent'),
                    'confidence': 'medium',
                    'evidence': f"Conexión con {conn.get('bytes_sent')} bytes enviados"
                }
                data_exfiltration.append(exfil)
        
        return data_exfiltration
    
    def _extract_ip_from_url(self, url):
        """Extrae la dirección IP de una URL"""
        try:
            from urllib.parse import urlparse
            parsed = urlparse(url)
            return parsed.netloc.split(':')[0]
        except:
            return ""
    
    def _extract_port_from_url(self, url):
        """Extrae el puerto de una URL"""
        try:
            from urllib.parse import urlparse
            parsed = urlparse(url)
            netloc = parsed.netloc
            if ':' in netloc:
                return int(netloc.split(':')[1])
            elif parsed.scheme == 'https':
                return 443
            else:
                return 80
        except:
            return 80
    
    def analyze_file(self, file_path, options=None):
        """Analiza un archivo en busca de comportamiento malicioso utilizando múltiples técnicas avanzadas"""
        if not os.path.exists(file_path):
            logger.error(f"El archivo {file_path} no existe")
            return {"error": "Archivo no encontrado"}
        
        options = options or {}
        results = {
            "file": file_path,
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "file_info": {},
            "static_analysis": {},
            "yara_matches": [],
            "heuristic_analysis": {},
            "behavior_analysis": {},
            "memory_analysis": {},
            "network_analysis": {},
            "iocs": {},
            "ai_detection": {},
            "mitre_att_ck": [],
            "verdict": {}
        }
        
        logger.info(f"Iniciando análisis avanzado de malware para: {file_path}")
        
        # Fase 1: Análisis estático básico
        logger.info("Fase 1: Realizando análisis estático básico...")
        file_info = self._get_file_info(file_path)
        results["file_info"] = file_info
        
        static_analysis = self._perform_static_analysis(file_path, file_info["type"])
        results["static_analysis"] = static_analysis
        
        if self.rules:
            yara_matches = self._scan_with_yara(file_path)
            results["yara_matches"] = yara_matches
        
        heuristic_results = self._heuristic_analysis(file_path, file_info, static_analysis)
        results["heuristic_analysis"] = heuristic_results
        
        # Fase 2: Análisis de comportamiento (si está habilitado)
        if self.sandbox_analysis:
            logger.info("Fase 2: Realizando análisis de comportamiento en sandbox...")
            behavior_results = self.analyze_behavior(file_path)
            results["behavior_analysis"] = behavior_results
        
        # Fase 3: Análisis de memoria (si está habilitado)
        if self.memory_analysis:
            logger.info("Fase 3: Realizando análisis de memoria...")
            memory_results = self.analyze_memory(file_path)
            results["memory_analysis"] = memory_results
        
        # Fase 4: Análisis de red (si está habilitado)
        if self.network_analysis:
            logger.info("Fase 4: Realizando análisis de actividad de red...")
            network_results = self.analyze_network(file_path)
            results["network_analysis"] = network_results
        
        # Fase 5: Extracción de IOCs (si está habilitado)
        if self.extract_iocs:
            logger.info("Fase 5: Extrayendo indicadores de compromiso (IOCs)...")
            iocs_results = self.extract_iocs(file_path, results)
            results["iocs"] = iocs_results
        
        # Fase 6: Detección mediante IA (si está habilitada)
        if self.ai_detection and self.ai_model:
            logger.info("Fase 6: Aplicando detección mediante IA...")
            ai_results = self._perform_ai_detection(file_path)
            results["ai_detection"] = ai_results
        
        # Fase 7: Mapeo a MITRE ATT&CK
        if any([self.sandbox_analysis, self.memory_analysis, self.network_analysis]):
            logger.info("Fase 7: Mapeando técnicas a MITRE ATT&CK...")
            mitre_results = self._map_to_mitre_attack(results)
            results["mitre_att_ck"] = mitre_results
        
        # Fase 8: Determinar veredicto final
        logger.info("Fase 8: Determinando veredicto final...")
        if self.ai_detection or self.sandbox_analysis or self.memory_analysis or self.network_analysis:
            results["verdict"] = self._determine_advanced_verdict(results)
        else:
            results["verdict"] = self._determine_verdict(results)
        
        # Fase 9: Análisis con VirusTotal (si está habilitado)
        if options.get("virustotal", False) and self.config.get("virustotal_api_key"):
            logger.info("Fase 9: Consultando VirusTotal...")
            vt_results = self._check_virustotal(file_info["hashes"]["md5"])
            results["virustotal"] = vt_results
        
        # Resumen del análisis
        verdict = results["verdict"]
        logger.info(f"Análisis avanzado completado para {file_path}")
        logger.info(f"Veredicto: {verdict.get('classification', 'Desconocido')} (confianza: {verdict.get('confidence', 0)})")
        if 'threat_level' in verdict:
            logger.info(f"Nivel de amenaza: {verdict.get('threat_level', 'Desconocido')}")
        if 'family' in verdict:
            logger.info(f"Familia de malware: {verdict.get('family', 'Desconocida')}")
        
        return results
        
    def _perform_ai_detection(self, file_path):
        """Realiza detección de malware mediante modelos de IA"""
        logger.info(f"Realizando detección mediante IA para {file_path}")
        ai_results = {
            'prediction': {},
            'feature_importance': {},
            'confidence': 0.0,
            'model_info': {}
        }
        
        try:
            # En una implementación real, se extraerían características del archivo
            # y se alimentarían a un modelo de aprendizaje automático
            
            # Simulamos resultados de la detección por IA
            ai_results['prediction'] = {
                'is_malware': True,
                'malware_type': 'ransomware',
                'family': 'WannaCry',
                'probability': 0.92
            }
            
            ai_results['feature_importance'] = {
                'api_calls': 0.35,
                'entropy': 0.25,
                'pe_sections': 0.20,
                'strings': 0.15,
                'imports': 0.05
            }
            
            ai_results['confidence'] = 0.92
            ai_results['model_info'] = self.ai_model if self.ai_model else {}
            
            logger.info(f"Detección por IA completada. Resultado: {ai_results['prediction']['is_malware']} (confianza: {ai_results['confidence']})")
            return ai_results
            
        except Exception as e:
            logger.error(f"Error durante la detección por IA: {str(e)}")
            return ai_results
            
    def _map_to_mitre_attack(self, results):
        """Mapea los resultados del análisis a técnicas de MITRE ATT&CK"""
        mitre_techniques = []
        
        # Mapear técnicas de evasión
        if 'behavior_analysis' in results and 'evasion_attempts' in results['behavior_analysis']:
            for evasion in results['behavior_analysis']['evasion_attempts']:
                if 'mitre_id' in evasion and evasion['mitre_id'] not in [t.get('technique_id') for t in mitre_techniques]:
                    mitre_techniques.append({
                        'technique_id': evasion['mitre_id'],
                        'technique_name': evasion['technique'],
                        'tactic': 'defense-evasion',
                        'description': evasion['description'],
                        'evidence': evasion.get('evidence', '')
                    })
        
        # Mapear técnicas de persistencia
        if 'behavior_analysis' in results and 'persistence_mechanisms' in results['behavior_analysis']:
            for persistence in results['behavior_analysis']['persistence_mechanisms']:
                if 'mitre_id' in persistence and persistence['mitre_id'] not in [t.get('technique_id') for t in mitre_techniques]:
                    mitre_techniques.append({
                        'technique_id': persistence['mitre_id'],
                        'technique_name': persistence['technique'],
                        'tactic': 'persistence',
                        'description': persistence['description'],
                        'evidence': persistence.get('evidence', '')
                    })
        
        # Mapear técnicas de C2
        if 'network_analysis' in results and 'c2_servers' in results['network_analysis']:
            if results['network_analysis']['c2_servers']:
                mitre_techniques.append({
                    'technique_id': 'T1071',
                    'technique_name': 'Application Layer Protocol',
                    'tactic': 'command-and-control',
                    'description': 'El malware utiliza protocolos de capa de aplicación para comunicarse con servidores C2',
                    'evidence': f"Detectados {len(results['network_analysis']['c2_servers'])} posibles servidores C2"
                })
        
        # Mapear técnicas de exfiltración de datos
        if 'network_analysis' in results and 'data_exfiltration' in results['network_analysis']:
            if results['network_analysis']['data_exfiltration']:
                mitre_techniques.append({
                    'technique_id': 'T1567',
                    'technique_name': 'Exfiltration Over Web Service',
                    'tactic': 'exfiltration',
                    'description': 'El malware exfiltra datos a través de servicios web',
                    'evidence': f"Detectados {len(results['network_analysis']['data_exfiltration'])} posibles eventos de exfiltración"
                })
        
        # Mapear técnicas de inyección de código
        if 'memory_analysis' in results and 'injected_code' in results['memory_analysis']:
            if results['memory_analysis']['injected_code']:
                mitre_techniques.append({
                    'technique_id': 'T1055',
                    'technique_name': 'Process Injection',
                    'tactic': 'defense-evasion,privilege-escalation',
                    'description': 'El malware inyecta código en otros procesos',
                    'evidence': f"Detectado código inyectado en {len(results['memory_analysis']['injected_code'])} procesos"
                })
        
        # Mapear técnicas basadas en coincidencias YARA
        for match in results.get('yara_matches', []):
            if 'ransomware' in match.get('rule', '').lower():
                mitre_techniques.append({
                    'technique_id': 'T1486',
                    'technique_name': 'Data Encrypted for Impact',
                    'tactic': 'impact',
                    'description': 'El malware cifra datos para causar impacto',
                    'evidence': f"Coincidencia con regla YARA: {match.get('rule', '')}"
                })
            elif 'keylogger' in match.get('rule', '').lower():
                mitre_techniques.append({
                    'technique_id': 'T1056.001',
                    'technique_name': 'Keylogging',
                    'tactic': 'collection',
                    'description': 'El malware captura pulsaciones de teclas',
                    'evidence': f"Coincidencia con regla YARA: {match.get('rule', '')}"
                })
        
        return mitre_techniques
        
    def _determine_advanced_verdict(self, results):
        """Determina un veredicto avanzado basado en todos los resultados del análisis"""
        # Inicializar veredicto
        verdict = {
            'classification': 'Limpio',
            'confidence': 0.0,
            'threat_level': 'Bajo',
            'family': '',
            'tags': []
        }
        
        # Sistema de puntuación para determinar la clasificación
        score = 0.0
        max_score = 0.0
        evidence_points = []
        
        # 1. Evaluar coincidencias YARA
        if results.get('yara_matches'):
            max_score += 30.0
            yara_score = min(len(results['yara_matches']) * 10.0, 30.0)
            score += yara_score
            evidence_points.append(f"Coincidencias YARA: {len(results['yara_matches'])}")
            
            # Extraer posible familia de malware de las reglas YARA
            for match in results['yara_matches']:
                rule_name = match.get('rule', '').lower()
                if 'ransomware' in rule_name:
                    if 'wannacry' in rule_name:
                        verdict['family'] = 'WannaCry'
                    elif 'ryuk' in rule_name:
                        verdict['family'] = 'Ryuk'
                    elif 'locky' in rule_name:
                        verdict['family'] = 'Locky'
                    else:
                        verdict['family'] = 'Ransomware genérico'
                    verdict['tags'].append('ransomware')
                elif 'trojan' in rule_name:
                    verdict['family'] = 'Troyano'
                    verdict['tags'].append('trojan')
                elif 'backdoor' in rule_name:
                    verdict['family'] = 'Backdoor'
                    verdict['tags'].append('backdoor')
        
        # 2. Evaluar análisis heurístico
        if results.get('heuristic_analysis'):
            max_score += 20.0
            heuristic = results['heuristic_analysis']
            
            # Evaluar factores de riesgo
            risk_count = len(heuristic.get('risk_factors', []))
            if risk_count > 0:
                score += min(risk_count * 2.5, 15.0)
                evidence_points.append(f"Factores de riesgo: {risk_count}")
            
            # Evaluar tipo potencial
            if heuristic.get('potential_type'):
                for pt in heuristic['potential_type']:
                    if pt.get('confidence', 0) > 70:
                        score += 5.0
                        evidence_points.append(f"Tipo potencial: {pt.get('type')} (confianza: {pt.get('confidence')}%)")
                        if not verdict['family'] and pt.get('type'):
                            verdict['family'] = pt.get('type').capitalize()
                            verdict['tags'].append(pt.get('type').lower())
        
        # 3. Evaluar análisis de comportamiento
        if results.get('behavior_analysis'):
            max_score += 25.0
            behavior = results['behavior_analysis']
            
            # Evaluar actividad de procesos sospechosos
            process_count = len(behavior.get('process_activity', []))
            if process_count > 2:
                score += min(process_count * 1.0, 5.0)
                evidence_points.append(f"Actividad de procesos sospechosos: {process_count}")
            
            # Evaluar técnicas de evasión
            evasion_count = len(behavior.get('evasion_attempts', []))
            if evasion_count > 0:
                score += min(evasion_count * 3.0, 10.0)
                evidence_points.append(f"Técnicas de evasión: {evasion_count}")
                verdict['tags'].append('evasion')
            
            # Evaluar mecanismos de persistencia
            persistence_count = len(behavior.get('persistence_mechanisms', []))
            if persistence_count > 0:
                score += min(persistence_count * 5.0, 10.0)
                evidence_points.append(f"Mecanismos de persistencia: {persistence_count}")
                verdict['tags'].append('persistence')
        
        # 4. Evaluar análisis de memoria
        if results.get('memory_analysis'):
            max_score += 15.0
            memory = results['memory_analysis']
            
            # Evaluar código inyectado
            injected_count = len(memory.get('injected_code', []))
            if injected_count > 0:
                score += min(injected_count * 5.0, 10.0)
                evidence_points.append(f"Código inyectado: {injected_count}")
                verdict['tags'].append('code_injection')
            
            # Evaluar funciones hookeadas
            hooked_count = len(memory.get('hooked_functions', []))
            if hooked_count > 0:
                score += min(hooked_count * 1.0, 5.0)
                evidence_points.append(f"Funciones hookeadas: {hooked_count}")
                verdict['tags'].append('api_hooking')
        
        # 5. Evaluar análisis de red
        if results.get('network_analysis'):
            max_score += 20.0
            network = results['network_analysis']
            
            # Evaluar servidores C2
            c2_count = len(network.get('c2_servers', []))
            if c2_count > 0:
                score += min(c2_count * 5.0, 10.0)
                evidence_points.append(f"Servidores C2: {c2_count}")
                verdict['tags'].append('c2')
            
            # Evaluar exfiltración de datos
            exfil_count = len(network.get('data_exfiltration', []))
            if exfil_count > 0:
                score += min(exfil_count * 5.0, 10.0)
                evidence_points.append(f"Eventos de exfiltración: {exfil_count}")
                verdict['tags'].append('data_exfiltration')
        
        # 6. Evaluar detección por IA
        if results.get('ai_detection') and results['ai_detection'].get('prediction'):
            max_score += 20.0
            ai_detection = results['ai_detection']
            
            if ai_detection['prediction'].get('is_malware', False):
                ai_score = ai_detection.get('confidence', 0) * 20.0
                score += ai_score
                evidence_points.append(f"Detección por IA: {ai_detection['prediction'].get('malware_type', 'malware')} (confianza: {ai_detection.get('confidence', 0)})")
                
                # Usar familia detectada por IA si no se ha determinado por YARA
                if not verdict['family'] and ai_detection['prediction'].get('family'):
                    verdict['family'] = ai_detection['prediction']['family']
                
                # Añadir tipo de malware a las etiquetas
                if ai_detection['prediction'].get('malware_type'):
                    verdict['tags'].append(ai_detection['prediction']['malware_type'])
        
        # 7. Evaluar resultados de VirusTotal
        if results.get('virustotal') and 'error' not in results['virustotal']:
            max_score += 20.0
            vt = results['virustotal']
            
            if vt.get('positives', 0) > 0 and vt.get('total', 0) > 0:
                vt_ratio = vt['positives'] / vt['total']
                vt_score = vt_ratio * 20.0
                score += vt_score
                evidence_points.append(f"VirusTotal: {vt['positives']}/{vt['total']} detecciones")
        
        # Calcular confianza normalizada
        if max_score > 0:
            verdict['confidence'] = min(score / max_score, 1.0)
        
        # Determinar clasificación y nivel de amenaza basados en la puntuación
        if score >= 50.0 or (results.get('virustotal', {}).get('positives', 0) > 10):
            verdict['classification'] = 'Malware'
            if score >= 80.0:
                verdict['threat_level'] = 'Crítico'
            elif score >= 65.0:
                verdict['threat_level'] = 'Alto'
            else:
                verdict['threat_level'] = 'Medio'
        elif score >= 30.0:
            verdict['classification'] = 'Sospechoso'
            verdict['threat_level'] = 'Medio'
        elif score >= 15.0:
            verdict['classification'] = 'Potencialmente no deseado'
            verdict['threat_level'] = 'Bajo'
        else:
            verdict['classification'] = 'Limpio'
            verdict['threat_level'] = 'Bajo'
        
        # Añadir evidencia al veredicto
        verdict['evidence'] = evidence_points
        
        return verdict
    
    def _get_file_info(self, file_path):
        """Obtiene información básica del archivo"""
        file_info = {
            "name": os.path.basename(file_path),
            "size": os.path.getsize(file_path),
            "type": magic.from_file(file_path),
            "mime": magic.from_file(file_path, mime=True),
            "created": datetime.fromtimestamp(os.path.getctime(file_path)).strftime("%Y-%m-%d %H:%M:%S"),
            "modified": datetime.fromtimestamp(os.path.getmtime(file_path)).strftime("%Y-%m-%d %H:%M:%S"),
            "hashes": self._calculate_hashes(file_path),
            "ssdeep": self._calculate_ssdeep(file_path)
        }
        return file_info
    
    def _calculate_hashes(self, file_path):
        """Calcula hashes criptográficos del archivo"""
        md5 = hashlib.md5()
        sha1 = hashlib.sha1()
        sha256 = hashlib.sha256()
        
        with open(file_path, 'rb') as f:
            data = f.read(8192)
            while data:
                md5.update(data)
                sha1.update(data)
                sha256.update(data)
                data = f.read(8192)
        
        return {
            "md5": md5.hexdigest(),
            "sha1": sha1.hexdigest(),
            "sha256": sha256.hexdigest()
        }
    
    def _calculate_ssdeep(self, file_path):
        """Calcula el hash fuzzy ssdeep"""
        try:
            return ssdeep.hash_from_file(file_path)
        except:
            return "N/A"
    
    def _perform_static_analysis(self, file_path, file_type):
        """Realiza análisis estático del archivo"""
        results = {
            "strings": self._extract_interesting_strings(file_path),
            "entropy": self._calculate_entropy(file_path)
        }
        
        # Análisis específico para ejecutables PE
        if "PE32" in file_type or "PE32+" in file_type:
            pe_info = self._analyze_pe(file_path)
            results["pe_info"] = pe_info
        
        # Análisis específico para scripts
        if "script" in file_type.lower() or file_path.endswith(('.js', '.vbs', '.ps1', '.py', '.sh')):
            script_info = self._analyze_script(file_path)
            results["script_info"] = script_info
        
        return results
    
    def _extract_interesting_strings(self, file_path):
        """Extrae cadenas interesantes del archivo"""
        interesting_strings = {
            "urls": [],
            "ips": [],
            "emails": [],
            "registry": [],
            "apis": [],
            "commands": [],
            "suspicious": []
        }
        
        # Implementación básica - en una versión real se usarían expresiones regulares más robustas
        import re
        with open(file_path, 'rb') as f:
            content = f.read().decode('latin-1')
            
            # URLs
            url_pattern = re.compile(r'https?://[\w\.-]+\.[a-zA-Z]{2,}[\w\.-/]*')
            interesting_strings["urls"] = url_pattern.findall(content)
            
            # IPs
            ip_pattern = re.compile(r'\b(?:\d{1,3}\.){3}\d{1,3}\b')
            interesting_strings["ips"] = ip_pattern.findall(content)
            
            # Emails
            email_pattern = re.compile(r'[\w\.-]+@[\w\.-]+\.[a-zA-Z]{2,}')
            interesting_strings["emails"] = email_pattern.findall(content)
            
            # Registro de Windows
            reg_pattern = re.compile(r'HKEY_[A-Z_]+\\[\w\\]+')
            interesting_strings["registry"] = reg_pattern.findall(content)
            
            # APIs sospechosas
            api_list = ["VirtualAlloc", "CreateProcess", "WriteProcessMemory", "CreateRemoteThread", 
                       "RegCreateKey", "HttpSendRequest", "InternetOpen", "ShellExecute"]
            for api in api_list:
                if api in content:
                    interesting_strings["apis"].append(api)
            
            # Comandos sospechosos
            cmd_list = ["cmd.exe", "powershell", "wget", "curl", "bitsadmin", "certutil", "wscript", "cscript"]
            for cmd in cmd_list:
                if cmd in content:
                    interesting_strings["commands"].append(cmd)
            
            # Cadenas sospechosas
            suspicious_list = ["password", "admin", "login", "credential", "bitcoin", "ransom", 
                             "encrypt", "decrypt", "hidden", "tor", "onion", "backdoor"]
            for sus in suspicious_list:
                if sus.lower() in content.lower():
                    interesting_strings["suspicious"].append(sus)
        
        # Eliminar duplicados
        for key in interesting_strings:
            interesting_strings[key] = list(set(interesting_strings[key]))
        
        return interesting_strings
    
    def _calculate_entropy(self, file_path):
        """Calcula la entropía de Shannon del archivo"""
        import math
        with open(file_path, 'rb') as f:
            data = f.read()
        
        if not data:
            return 0.0
        
        entropy = 0
        for x in range(256):
            p_x = float(data.count(x)) / len(data)
            if p_x > 0:
                entropy += - p_x * math.log(p_x, 2)
        
        return entropy
    
    def _analyze_pe(self, file_path):
        """Analiza un archivo ejecutable PE"""
        try:
            pe = pefile.PE(file_path)
            result = {
                "sections": [],
                "imports": {},
                "exports": [],
                "resources": [],
                "timestamp": pe.FILE_HEADER.TimeDateStamp,
                "entrypoint": pe.OPTIONAL_HEADER.AddressOfEntryPoint,
                "image_base": pe.OPTIONAL_HEADER.ImageBase,
                "subsystem": pe.OPTIONAL_HEADER.Subsystem,
                "dll_characteristics": pe.OPTIONAL_HEADER.DllCharacteristics,
                "suspicious_indicators": []
            }
            
            # Secciones
            for section in pe.sections:
                section_info = {
                    "name": section.Name.decode('utf-8', 'ignore').strip('\x00'),
                    "virtual_address": section.VirtualAddress,
                    "virtual_size": section.Misc_VirtualSize,
                    "raw_size": section.SizeOfRawData,
                    "entropy": section.get_entropy()
                }
                result["sections"].append(section_info)
                
                # Detectar secciones sospechosas
                if section_info["entropy"] > 7.0:
                    result["suspicious_indicators"].append(f"Alta entropía en sección {section_info['name']} ({section_info['entropy']:.2f})")
            
            # Importaciones
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    dll_name = entry.dll.decode('utf-8', 'ignore')
                    result["imports"][dll_name] = []
                    for imp in entry.imports:
                        if imp.name:
                            result["imports"][dll_name].append(imp.name.decode('utf-8', 'ignore'))
            
            # Exportaciones
            if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
                for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                    if exp.name:
                        result["exports"].append(exp.name.decode('utf-8', 'ignore'))
            
            # Recursos
            if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
                for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                    if hasattr(resource_type, 'directory'):
                        for resource_id in resource_type.directory.entries:
                            if hasattr(resource_id, 'directory'):
                                for resource_lang in resource_id.directory.entries:
                                    result["resources"].append({
                                        "type": resource_type.id,
                                        "id": resource_id.id,
                                        "lang": resource_lang.id,
                                        "size": resource_lang.data.struct.Size
                                    })
            
            # Indicadores de sospecha
            suspicious_dlls = ["wininet.dll", "urlmon.dll", "ws2_32.dll", "crypt32.dll"]
            suspicious_apis = ["VirtualAlloc", "WriteProcessMemory", "CreateRemoteThread", "HttpSendRequest"]
            
            for dll in suspicious_dlls:
                if dll.lower() in [d.lower() for d in result["imports"]]:
                    result["suspicious_indicators"].append(f"Importación de DLL sospechosa: {dll}")
            
            for dll, imports in result["imports"].items():
                for api in suspicious_apis:
                    if any(api.lower() in imp.lower() for imp in imports):
                        result["suspicious_indicators"].append(f"API sospechosa: {api} en {dll}")
            
            # Comprobar si es un ejecutable empaquetado
            packed_sections = [".UPX", ".packed", ".nsp", ".enigma"]
            for section in result["sections"]:
                if any(p in section["name"] for p in packed_sections):
                    result["suspicious_indicators"].append(f"Posible empaquetado: {section['name']}")
            
            # Comprobar si hay secciones ejecutables con alta entropía
            for section in pe.sections:
                if section.get_entropy() > 7.0 and section.IMAGE_SCN_MEM_EXECUTE:
                    result["suspicious_indicators"].append(f"Sección ejecutable con alta entropía: {section.Name.decode('utf-8', 'ignore').strip('\x00')}")
            
            return result
        except Exception as e:
            logger.error(f"Error al analizar PE: {e}")
            return {"error": str(e)}
    
    def _analyze_script(self, file_path):
        """Analiza un archivo de script"""
        result = {
            "obfuscation_level": "bajo",
            "suspicious_functions": [],
            "suspicious_patterns": []
        }
        
        with open(file_path, 'r', encoding='latin-1') as f:
            content = f.read()
        
        # Detectar ofuscación
        obfuscation_indicators = {
            "alto": ["eval(", "String.fromCharCode", "unescape(", "atob(", "\\x", "\\u"],
            "medio": ["charCodeAt", "substr", "substring", "replace(", "split(", "join("]
        }
        
        high_count = sum(content.count(ind) for ind in obfuscation_indicators["alto"])
        medium_count = sum(content.count(ind) for ind in obfuscation_indicators["medio"])
        
        if high_count > 5:
            result["obfuscation_level"] = "alto"
        elif high_count > 0 or medium_count > 10:
            result["obfuscation_level"] = "medio"
        
        # Detectar funciones sospechosas
        suspicious_js = ["eval", "document.write", "window.open", "XMLHttpRequest", "ActiveXObject", "WScript.Shell"]
        suspicious_ps = ["Invoke-Expression", "IEX", "New-Object", "Start-Process", "Invoke-WebRequest", "DownloadString"]
        suspicious_py = ["exec", "eval", "os.system", "subprocess", "requests", "urllib"]
        
        for func in suspicious_js + suspicious_ps + suspicious_py:
            if func in content:
                result["suspicious_functions"].append(func)
        
        # Detectar patrones sospechosos
        patterns = {
            "base64": r"[A-Za-z0-9+/]{50,}={0,2}",
            "ip_address": r"\b(?:\d{1,3}\.){3}\d{1,3}\b",
            "url": r"https?://[\w\.-]+\.[a-zA-Z]{2,}[\w\.-/]*",
            "powershell_encoded": r"-enc[odedCommand]* [A-Za-z0-9+/]{50,}={0,2}",
            "cmd_execution": r"cmd\.exe|powershell\.exe|bash|sh\s+-c"
        }
        
        import re
        for pattern_name, pattern in patterns.items():
            matches = re.findall(pattern, content)
            if matches:
                result["suspicious_patterns"].append({
                    "type": pattern_name,
                    "count": len(matches),
                    "samples": matches[:3]  # Limitar a 3 ejemplos
                })
        
        return result
    
    def _scan_with_yara(self, file_path):
        """Escanea el archivo con reglas YARA"""
        if not self.rules:
            return []
        
        try:
            matches = self.rules.match(file_path)
            results = []
            
            for match in matches:
                result = {
                    "rule": match.rule,
                    "meta": match.meta,
                    "strings": [],
                    "tags": match.tags
                }
                
                # Extraer cadenas coincidentes
                for string_id, instances in match.strings.items():
                    for offset, name, string_data in instances:
                        try:
                            string_value = string_data.decode('utf-8', 'ignore')
                        except:
                            string_value = str(string_data)
                        
                        result["strings"].append({
                            "offset": offset,
                            "name": name.decode() if isinstance(name, bytes) else name,
                            "value": string_value
                        })
                
                results.append(result)
            
            return results
        except Exception as e:
            logger.error(f"Error en el escaneo YARA: {e}")
            return []
    
    def _heuristic_analysis(self, file_path, file_info, static_analysis):
        """Realiza análisis heurístico para detectar comportamientos sospechosos"""
        result = {
            "risk_score": 0,
            "risk_factors": [],
            "potential_type": []
        }
        
        # Factores de riesgo basados en información del archivo
        if file_info["entropy"] > 7.0:
            result["risk_score"] += 20
            result["risk_factors"].append("Alta entropía general (posible cifrado/empaquetado)")
        
        # Factores de riesgo basados en cadenas
        strings = static_analysis.get("strings", {})
        
        if len(strings.get("urls", [])) > 5:
            result["risk_score"] += 10
            result["risk_factors"].append(f"Múltiples URLs ({len(strings.get('urls', []))})")
        
        if len(strings.get("ips", [])) > 3:
            result["risk_score"] += 15
            result["risk_factors"].append(f"Múltiples direcciones IP ({len(strings.get('ips', []))})")
        
        if len(strings.get("registry", [])) > 5:
            result["risk_score"] += 15
            result["risk_factors"].append("Múltiples accesos al registro")
        
        if len(strings.get("apis", [])) > 3:
            result["risk_score"] += 15
            result["risk_factors"].append("Uso de APIs potencialmente peligrosas")
        
        # Factores de riesgo basados en análisis PE
        pe_info = static_analysis.get("pe_info", {})
        
        for indicator in pe_info.get("suspicious_indicators", []):
            result["risk_score"] += 10
            result["risk_factors"].append(indicator)
        
        # Factores de riesgo basados en análisis de scripts
        script_info = static_analysis.get("script_info", {})
        
        if script_info.get("obfuscation_level") == "alto":
            result["risk_score"] += 25
            result["risk_factors"].append("Alto nivel de ofuscación")
        elif script_info.get("obfuscation_level") == "medio":
            result["risk_score"] += 15
            result["risk_factors"].append("Nivel medio de ofuscación")
        
        if len(script_info.get("suspicious_functions", [])) > 3:
            result["risk_score"] += 20
            result["risk_factors"].append("Uso de múltiples funciones sospechosas")
        
        # Determinar posible tipo de malware
        for malware_type, info in MALWARE_TYPES.items():
            score = 0
            
            # Comprobar indicadores en cadenas
            for indicator in info.get("indicadores", []):
                for s in strings.get("suspicious", []):
                    if indicator.lower() in s.lower():
                        score += 10
            
            # Comprobar extensiones (para ransomware)
            if "extensiones_comunes" in info:
                for ext in info["extensiones_comunes"]:
                    if ext in file_path.lower():
                        score += 20
            
            # Comprobar familias (para troyanos)
            if "familias_comunes" in info:
                for familia in info["familias_comunes"]:
                    for s in strings.get("suspicious", []):
                        if familia.lower() in s.lower():
                            score += 15
            
            # Si la puntuación es suficiente, añadir como posible tipo
            if score >= 20:
                result["potential_type"].append({
                    "type": malware_type,
                    "confidence": min(score, 100),
                    "description": info["descripcion"]
                })
        
        # Ordenar por confianza
        result["potential_type"] = sorted(result["potential_type"], key=lambda x: x["confidence"], reverse=True)
        
        return result
    
    def _determine_verdict(self, results):
        """Determina el veredicto final basado en todos los análisis"""
        risk_score = results["heuristic_analysis"]["risk_score"]
        yara_matches = len(results["yara_matches"])
        
        verdict = {
            "risk_level": "desconocido",
            "confidence": 0,
            "summary": ""
        }
        
        # Determinar nivel de riesgo
        if risk_score >= 70 or yara_matches >= 2:
            verdict["risk_level"] = "alto"
            verdict["confidence"] = min(90, risk_score)
        elif risk_score >= 40 or yara_matches >= 1:
            verdict["risk_level"] = "medio"
            verdict["confidence"] = min(70, risk_score)
        elif risk_score >= 20:
            verdict["risk_level"] = "bajo"
            verdict["confidence"] = min(50, risk_score)
        else:
            verdict["risk_level"] = "limpio"
            verdict["confidence"] = max(10, 100 - risk_score)
        
        # Generar resumen
        if verdict["risk_level"] == "alto":
            verdict["summary"] = "El archivo muestra claros indicadores de comportamiento malicioso."
        elif verdict["risk_level"] == "medio":
            verdict["summary"] = "El archivo muestra algunos comportamientos sospechosos que podrían indicar código malicioso."
        elif verdict["risk_level"] == "bajo":
            verdict["summary"] = "El archivo muestra pocos comportamientos sospechosos, pero requiere más análisis."
        else:
            verdict["summary"] = "No se han detectado comportamientos maliciosos significativos en el archivo."
        
        # Añadir información sobre el posible tipo de malware
        potential_types = results["heuristic_analysis"]["potential_type"]
        if potential_types:
            top_type = potential_types[0]
            verdict["summary"] += f" Posible clasificación: {top_type['type'].upper()} ({top_type['confidence']}% de confianza)."
        
        return verdict
    
    def _check_virustotal(self, file_hash):
        """Consulta VirusTotal para obtener información sobre el hash"""
        api_key = self.config.get("virustotal_api_key")
        if not api_key:
            return {"error": "No se ha configurado la API key de VirusTotal"}
        
        url = f"https://www.virustotal.com/api/v3/files/{file_hash}"
        headers = {"x-apikey": api_key}
        
        try:
            response = requests.get(url, headers=headers)
            if response.status_code == 200:
                data = response.json()
                attributes = data.get("data", {}).get("attributes", {})
                
                result = {
                    "positives": attributes.get("last_analysis_stats", {}).get("malicious", 0),
                    "total": sum(attributes.get("last_analysis_stats", {}).values()),
                    "scan_date": attributes.get("last_analysis_date"),
                    "permalink": f"https://www.virustotal.com/gui/file/{file_hash}",
                    "scans": {}
                }
                
                # Extraer resultados de los principales antivirus
                scans = attributes.get("last_analysis_results", {})
                main_avs = ["Microsoft", "Kaspersky", "Symantec", "McAfee", "ClamAV", "Sophos", "Avast"]
                
                for av in main_avs:
                    if av in scans:
                        result["scans"][av] = {
                            "detected": scans[av].get("category") == "malicious",
                            "result": scans[av].get("result")
                        }
                
                return result
            else:
                return {"error": f"Error en la consulta a VirusTotal: {response.status_code}"}
        except Exception as e:
            return {"error": f"Error al consultar VirusTotal: {str(e)}"}
    
    def generate_report(self, analysis_results, format="text"):
        """Genera un informe del análisis en el formato especificado"""
        if format == "json":
            return json.dumps(analysis_results, indent=4)
        
        elif format == "html":
            # Plantilla HTML básica
            html_template = """
            <!DOCTYPE html>
            <html>
            <head>
                <title>Informe de Análisis Avanzado de Malware - UnityDex</title>
                <style>
                    body { font-family: Arial, sans-serif; margin: 20px; }
                    h1, h2, h3 { color: #333; }
                    .high { color: #d9534f; font-weight: bold; }
                    .medium { color: #f0ad4e; font-weight: bold; }
                    .low { color: #5bc0de; font-weight: bold; }
                    .clean { color: #5cb85c; font-weight: bold; }
                    table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
                    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                    th { background-color: #f2f2f2; }
                    tr:nth-child(even) { background-color: #f9f9f9; }
                    .section { margin-bottom: 30px; border: 1px solid #eee; padding: 15px; border-radius: 5px; }
                    .subsection { margin: 10px 0; padding: 10px; background-color: #f9f9f9; border-radius: 3px; }
                    .mitre { background-color: #e8f4f8; padding: 5px; border-radius: 3px; }
                    .evidence { font-style: italic; color: #666; }
                    .nav { position: fixed; top: 0; right: 0; background: white; padding: 10px; border: 1px solid #ddd; border-radius: 0 0 0 5px; }
                    .nav a { display: block; margin: 5px 0; text-decoration: none; color: #337ab7; }
                    .nav a:hover { text-decoration: underline; }
                </style>
            </head>
            <body>
                <div class="nav">
                    <a href="#resumen">Resumen</a>
                    <a href="#archivo">Información del archivo</a>
                    <a href="#riesgo">Factores de riesgo</a>
                    <a href="#clasificacion">Clasificación</a>
                    <a href="#yara">YARA</a>
                    {nav_behavior}
                    {nav_memory}
                    {nav_network}
                    {nav_iocs}
                    {nav_mitre}
                    {nav_ai}
                    <a href="#virustotal">VirusTotal</a>
                    <a href="#strings">Cadenas</a>
                </div>
                
                <h1>Informe de Análisis Avanzado de Malware - UnityDex</h1>
                
                <div class="section" id="resumen">
                    <h2>Resumen</h2>
                    <p><strong>Archivo:</strong> {file}</p>
                    <p><strong>Fecha de análisis:</strong> {timestamp}</p>
                    <p><strong>Nivel de riesgo:</strong> <span class="{risk_class}">{risk_level}</span></p>
                    <p><strong>Confianza:</strong> {confidence}%</p>
                    <p><strong>Resumen:</strong> {summary}</p>
                    {family_info}
                    {tags_info}
                </div>
                
                <div class="section" id="archivo">
                    <h2>Información del archivo</h2>
                    <table>
                        <tr><th>Nombre</th><td>{name}</td></tr>
                        <tr><th>Tamaño</th><td>{size} bytes</td></tr>
                        <tr><th>Tipo</th><td>{type}</td></tr>
                        <tr><th>MIME</th><td>{mime}</td></tr>
                        <tr><th>Creado</th><td>{created}</td></tr>
                        <tr><th>Modificado</th><td>{modified}</td></tr>
                        <tr><th>MD5</th><td>{md5}</td></tr>
                        <tr><th>SHA1</th><td>{sha1}</td></tr>
                        <tr><th>SHA256</th><td>{sha256}</td></tr>
                        <tr><th>SSDeep</th><td>{ssdeep}</td></tr>
                    </table>
                </div>
                
                <div class="section" id="riesgo">
                    <h2>Factores de riesgo</h2>
                    <ul>
                        {risk_factors}
                    </ul>
                </div>
                
                <div class="section" id="clasificacion">
                    <h2>Posible clasificación</h2>
                    <table>
                        <tr><th>Tipo</th><th>Confianza</th><th>Descripción</th></tr>
                        {potential_types}
                    </table>
                </div>
                
                <div class="section" id="yara">
                    <h2>Coincidencias YARA</h2>
                    {yara_matches}
                </div>
                
                {behavior_section}
                
                {memory_section}
                
                {network_section}
                
                {iocs_section}
                
                {mitre_section}
                
                {ai_section}
                
                {virustotal_section}
                
                <div class="section" id="strings">
                    <h2>Cadenas interesantes</h2>
                    <h3>URLs</h3>
                    <ul>{urls}</ul>
                    <h3>Direcciones IP</h3>
                    <ul>{ips}</ul>
                    <h3>Claves de registro</h3>
                    <ul>{registry}</ul>
                    <h3>APIs sospechosas</h3>
                    <ul>{apis}</ul>
                </div>
                
                <footer>
                    <p>Generado por UnityDex Malware Analyzer v2.0 - Análisis Avanzado</p>
                </footer>
            </body>
            </html>
            """
            
            # Preparar datos para la plantilla
            file_info = analysis_results["file_info"]
            verdict = analysis_results["verdict"]
            heuristic = analysis_results["heuristic_analysis"]
            strings = analysis_results["static_analysis"].get("strings", {})
            
            # Mapear nivel de riesgo a clase CSS
            risk_class_map = {"alto": "high", "medio": "medium", "bajo": "low", "limpio": "clean", "desconocido": ""}
            
            # Generar HTML para factores de riesgo
            risk_factors_html = ""
            for factor in heuristic["risk_factors"]:
                risk_factors_html += f"<li>{factor}</li>\n"
            
            # Generar HTML para tipos potenciales
            potential_types_html = ""
            for pt in heuristic["potential_type"]:
                potential_types_html += f"<tr><td>{pt['type']}</td><td>{pt['confidence']}%</td><td>{pt['description']}</td></tr>\n"
            
            # Generar HTML para coincidencias YARA
            yara_matches_html = ""
            if analysis_results["yara_matches"]:
                for match in analysis_results["yara_matches"]:
                    yara_matches_html += f"<h3>Regla: {match['rule']}</h3>\n"
                    if match.get("meta"):
                        yara_matches_html += "<h4>Metadatos</h4>\n<ul>\n"
                        for k, v in match["meta"].items():
                            yara_matches_html += f"<li><strong>{k}:</strong> {v}</li>\n"
                        yara_matches_html += "</ul>\n"
            else:
                yara_matches_html = "<p>No se encontraron coincidencias con reglas YARA.</p>"
            
            # Generar HTML para VirusTotal
            virustotal_html = ""
            if "virustotal" in analysis_results:
                vt = analysis_results["virustotal"]
                if "error" not in vt:
                    virustotal_html = f"""
                    <div class="section">
                        <h2>Resultados de VirusTotal</h2>
                        <p><strong>Detecciones:</strong> {vt['positives']}/{vt['total']}</p>
                        <p><strong>Enlace:</strong> <a href="{vt['permalink']}" target="_blank">{vt['permalink']}</a></p>
                        <h3>Principales antivirus</h3>
                        <table>
                            <tr><th>Antivirus</th><th>Detectado</th><th>Resultado</th></tr>
                    """
                    
                    for av, result in vt["scans"].items():
                        detected = "Sí" if result["detected"] else "No"
                        av_result = result["result"] if result["detected"] else "-"
                        virustotal_html += f"<tr><td>{av}</td><td>{detected}</td><td>{av_result}</td></tr>\n"
                    
                    virustotal_html += "</table>\n</div>"
                else:
                    virustotal_html = f"""
                    <div class="section">
                        <h2>Resultados de VirusTotal</h2>
                        <p>Error: {vt['error']}</p>
                    </div>
                    """
            
            # Generar HTML para listas de cadenas
            urls_html = ""
            for url in strings.get("urls", [])[:10]:  # Limitar a 10 elementos
                urls_html += f"<li>{url}</li>\n"
            
            ips_html = ""
            for ip in strings.get("ips", [])[:10]:
                ips_html += f"<li>{ip}</li>\n"
            
            registry_html = ""
            for reg in strings.get("registry", [])[:10]:
                registry_html += f"<li>{reg}</li>\n"
            
            apis_html = ""
            for api in strings.get("apis", [])[:10]:
                apis_html += f"<li>{api}</li>\n"
            
            # Generar secciones condicionales y navegación
            nav_behavior = ""
            nav_memory = ""
            nav_network = ""
            nav_iocs = ""
            nav_mitre = ""
            nav_ai = ""
            family_info = ""
            tags_info = ""
            behavior_section = ""
            memory_section = ""
            network_section = ""
            iocs_section = ""
            mitre_section = ""
            ai_section = ""
            
            # Información de familia y tags si están disponibles
            if verdict.get('family'):
                family_info = f"<p><strong>Familia de malware:</strong> <span class=\"high\">{verdict['family']}</span></p>"
            
            if verdict.get('tags'):
                tags_html = ""
                for tag in verdict['tags']:
                    tags_html += f"<span class=\"mitre\">{tag}</span> "
                tags_info = f"<p><strong>Tags:</strong> {tags_html}</p>"
            
            # Sección de análisis de comportamiento
            if "behavior_analysis" in analysis_results and analysis_results["behavior_analysis"]:
                nav_behavior = '<a href="#behavior">Análisis de comportamiento</a>'
                behavior = analysis_results["behavior_analysis"]
                
                # Procesos
                process_html = "<p>No se detectaron procesos sospechosos.</p>"
                if behavior.get('process_activity'):
                    process_html = "<ul>"
                    for proc in behavior['process_activity']:
                        process_html += f"<li><strong>{proc.get('process', 'Desconocido')}</strong> (PID: {proc.get('pid', 'N/A')})"
                        if proc.get('command_line'):
                            process_html += f" - Cmd: {proc.get('command_line')}"
                        process_html += "</li>"
                    process_html += "</ul>"
                
                # Actividad de archivos
                file_activity_html = "<p>No se detectó actividad de archivos sospechosa.</p>"
                if behavior.get('file_activity'):
                    file_activity_html = "<ul>"
                    for file_act in behavior['file_activity']:
                        file_activity_html += f"<li><strong>{file_act.get('type', 'Operación desconocida')}</strong>: {file_act.get('path', 'Ruta desconocida')}</li>"
                    file_activity_html += "</ul>"
                
                # Actividad de registro
                registry_activity_html = "<p>No se detectó actividad de registro sospechosa.</p>"
                if behavior.get('registry_activity'):
                    registry_activity_html = "<ul>"
                    for reg_act in behavior['registry_activity']:
                        registry_activity_html += f"<li><strong>{reg_act.get('type', 'Operación desconocida')}</strong>: {reg_act.get('key', 'Clave desconocida')}"
                        if reg_act.get('value') and reg_act.get('data'):
                            registry_activity_html += f" - Valor: {reg_act.get('value')} = {reg_act.get('data')}"
                        registry_activity_html += "</li>"
                    registry_activity_html += "</ul>"
                
                # Técnicas de evasión
                evasion_html = "<p>No se detectaron técnicas de evasión.</p>"
                if behavior.get('evasion_attempts'):
                    evasion_html = "<ul>"
                    for evasion in behavior['evasion_attempts']:
                        evasion_html += f"<li><strong>{evasion.get('technique', 'Técnica desconocida')}</strong>: {evasion.get('description', 'Sin descripción')}"
                        if evasion.get('mitre_id'):
                            evasion_html += f" <span class=\"mitre\">{evasion.get('mitre_id')}</span>"
                        evasion_html += "</li>"
                    evasion_html += "</ul>"
                
                # Mecanismos de persistencia
                persistence_html = "<p>No se detectaron mecanismos de persistencia.</p>"
                if behavior.get('persistence_mechanisms'):
                    persistence_html = "<ul>"
                    for persistence in behavior['persistence_mechanisms']:
                        persistence_html += f"<li><strong>{persistence.get('technique', 'Mecanismo desconocido')}</strong>: {persistence.get('description', 'Sin descripción')}"
                        if persistence.get('mitre_id'):
                            persistence_html += f" <span class=\"mitre\">{persistence.get('mitre_id')}</span>"
                        persistence_html += "</li>"
                    persistence_html += "</ul>"
                
                # Resumen de comportamiento
                behavior_summary = behavior.get('summary', {})
                severity_class = "low"
                if behavior_summary.get('severity') == "high":
                    severity_class = "high"
                elif behavior_summary.get('severity') == "medium":
                    severity_class = "medium"
                
                behavior_section = f"""
                <div class="section" id="behavior">
                    <h2>Análisis de comportamiento</h2>
                    <div class="subsection">
                        <h3>Resumen de comportamiento</h3>
                        <p><strong>Severidad:</strong> <span class="{severity_class}">{behavior_summary.get('severity', 'baja')}</span></p>
                        <p><strong>Confianza:</strong> {behavior_summary.get('confidence', '0')}%</p>
                        <p><strong>Descripción:</strong> {behavior_summary.get('description', 'No disponible')}</p>
                    </div>
                    
                    <div class="subsection">
                        <h3>Procesos</h3>
                        {process_html}
                    </div>
                    
                    <div class="subsection">
                        <h3>Actividad de archivos</h3>
                        {file_activity_html}
                    </div>
                    
                    <div class="subsection">
                        <h3>Actividad de registro</h3>
                        {registry_activity_html}
                    </div>
                    
                    <div class="subsection">
                        <h3>Técnicas de evasión</h3>
                        {evasion_html}
                    </div>
                    
                    <div class="subsection">
                        <h3>Mecanismos de persistencia</h3>
                        {persistence_html}
                    </div>
                </div>
                """
            
            # Sección de análisis de memoria
            if "memory_analysis" in analysis_results and analysis_results["memory_analysis"]:
                nav_memory = '<a href="#memory">Análisis de memoria</a>'
                memory = analysis_results["memory_analysis"]
                
                # Código inyectado
                injected_code_html = "<p>No se detectó código inyectado.</p>"
                if memory.get('injected_code'):
                    injected_code_html = "<ul>"
                    for code in memory['injected_code']:
                        injected_code_html += f"<li><strong>{code.get('process', 'Proceso desconocido')}</strong>: Región {code.get('region', 'Desconocida')}"
                        if code.get('protection'):
                            injected_code_html += f" (Protección: {code.get('protection')})"
                        if code.get('mitre_id'):
                            injected_code_html += f" <span class=\"mitre\">{code.get('mitre_id')}</span>"
                        injected_code_html += "</li>"
                    injected_code_html += "</ul>"
                
                # Procesos ocultos
                hidden_processes_html = "<p>No se detectaron procesos ocultos.</p>"
                if memory.get('hidden_processes'):
                    hidden_processes_html = "<ul>"
                    for proc in memory['hidden_processes']:
                        hidden_processes_html += f"<li><strong>{proc.get('name', 'Proceso desconocido')}</strong> (PID: {proc.get('pid', 'N/A')})"
                        if proc.get('technique'):
                            hidden_processes_html += f" - Técnica: {proc.get('technique')}"
                        if proc.get('mitre_id'):
                            hidden_processes_html += f" <span class=\"mitre\">{proc.get('mitre_id')}</span>"
                        hidden_processes_html += "</li>"
                    hidden_processes_html += "</ul>"
                
                # Funciones hookeadas
                hooked_functions_html = "<p>No se detectaron funciones hookeadas.</p>"
                if memory.get('hooked_functions'):
                    hooked_functions_html = "<ul>"
                    for func in memory['hooked_functions']:
                        hooked_functions_html += f"<li><strong>{func.get('module', 'Módulo desconocido')}::{func.get('function', 'Función desconocida')}</strong>"
                        if func.get('hook_type'):
                            hooked_functions_html += f" (Tipo: {func.get('hook_type')})"
                        if func.get('mitre_id'):
                            hooked_functions_html += f" <span class=\"mitre\">{func.get('mitre_id')}</span>"
                        hooked_functions_html += "</li>"
                    hooked_functions_html += "</ul>"
                
                # Resumen de memoria
                memory_summary = memory.get('summary', {})
                severity_class = "low"
                if memory_summary.get('severity') == "high":
                    severity_class = "high"
                elif memory_summary.get('severity') == "medium":
                    severity_class = "medium"
                
                memory_section = f"""
                <div class="section" id="memory">
                    <h2>Análisis de memoria</h2>
                    <div class="subsection">
                        <h3>Resumen de análisis de memoria</h3>
                        <p><strong>Severidad:</strong> <span class="{severity_class}">{memory_summary.get('severity', 'baja')}</span></p>
                        <p><strong>Confianza:</strong> {memory_summary.get('confidence', '0')}%</p>
                        <p><strong>Descripción:</strong> {memory_summary.get('description', 'No disponible')}</p>
                    </div>
                    
                    <div class="subsection">
                        <h3>Código inyectado</h3>
                        {injected_code_html}
                    </div>
                    
                    <div class="subsection">
                        <h3>Procesos ocultos</h3>
                        {hidden_processes_html}
                    </div>
                    
                    <div class="subsection">
                        <h3>Funciones hookeadas</h3>
                        {hooked_functions_html}
                    </div>
                </div>
                """
            
            # Sección de análisis de red
            if "network_analysis" in analysis_results and analysis_results["network_analysis"]:
                nav_network = '<a href="#network">Análisis de red</a>'
                network = analysis_results["network_analysis"]
                
                # Peticiones DNS
                dns_requests_html = "<p>No se detectaron peticiones DNS.</p>"
                if network.get('dns_requests'):
                    dns_requests_html = "<ul>"
                    for dns in network['dns_requests']:
                        dns_requests_html += f"<li><strong>{dns.get('domain', 'Dominio desconocido')}</strong> → {dns.get('response', 'N/A')}</li>"
                    dns_requests_html += "</ul>"
                
                # Peticiones HTTP
                http_requests_html = "<p>No se detectaron peticiones HTTP.</p>"
                if network.get('http_requests'):
                    http_requests_html = "<ul>"
                    for http in network['http_requests']:
                        http_requests_html += f"<li><strong>{http.get('method', 'GET')}</strong> {http.get('url', 'URL desconocida')}"
                        if http.get('user_agent'):
                            http_requests_html += f"<div class=\"evidence\">User-Agent: {http.get('user_agent')}</div>"
                        http_requests_html += "</li>"
                    http_requests_html += "</ul>"
                
                # Conexiones de red
                connections_html = "<p>No se detectaron conexiones de red.</p>"
                if network.get('connections'):
                    connections_html = "<ul>"
                    for conn in network['connections']:
                        connections_html += f"<li><strong>{conn.get('destination_ip', '0.0.0.0')}:{conn.get('destination_port', '0')}</strong> ({conn.get('protocol', 'TCP')})"
                        if conn.get('bytes_sent') and conn.get('bytes_received'):
                            connections_html += f"<div class=\"evidence\">Datos: {conn.get('bytes_sent', 0)} bytes enviados, {conn.get('bytes_received', 0)} bytes recibidos</div>"
                        connections_html += "</li>"
                    connections_html += "</ul>"
                
                # Servidores C2
                c2_servers_html = "<p>No se detectaron servidores C2.</p>"
                if network.get('c2_servers'):
                    c2_servers_html = "<ul>"
                    for c2 in network['c2_servers']:
                        c2_servers_html += f"<li><strong>{c2.get('address', 'Dirección desconocida')}</strong> (Confianza: {c2.get('confidence', 'Baja')})"
                        if c2.get('protocol'):
                            c2_servers_html += f" - Protocolo: {c2.get('protocol')}"
                        if c2.get('mitre_id'):
                            c2_servers_html += f" <span class=\"mitre\">{c2.get('mitre_id')}</span>"
                        if c2.get('evidence'):
                            c2_servers_html += f"<div class=\"evidence\">Evidencia: {c2.get('evidence')}</div>"
                        c2_servers_html += "</li>"
                    c2_servers_html += "</ul>"
                
                # Exfiltración de datos
                data_exfiltration_html = "<p>No se detectó exfiltración de datos.</p>"
                if network.get('data_exfiltration'):
                    data_exfiltration_html = "<ul>"
                    for exfil in network['data_exfiltration']:
                        data_exfiltration_html += f"<li><strong>{exfil.get('destination', 'Destino desconocido')}</strong>"
                        if exfil.get('protocol') and exfil.get('size'):
                            data_exfiltration_html += f" - {exfil.get('protocol')}, {exfil.get('size')} bytes"
                        if exfil.get('mitre_id'):
                            data_exfiltration_html += f" <span class=\"mitre\">{exfil.get('mitre_id')}</span>"
                        if exfil.get('evidence'):
                            data_exfiltration_html += f"<div class=\"evidence\">Evidencia: {exfil.get('evidence')}</div>"
                        data_exfiltration_html += "</li>"
                    data_exfiltration_html += "</ul>"
                
                # Resumen de red
                network_summary = network.get('summary', {})
                severity_class = "low"
                if network_summary.get('severity') == "high":
                    severity_class = "high"
                elif network_summary.get('severity') == "medium":
                    severity_class = "medium"
                
                network_section = f"""
                <div class="section" id="network">
                    <h2>Análisis de red</h2>
                    <div class="subsection">
                        <h3>Resumen de análisis de red</h3>
                        <p><strong>Severidad:</strong> <span class="{severity_class}">{network_summary.get('severity', 'baja')}</span></p>
                        <p><strong>Confianza:</strong> {network_summary.get('confidence', '0')}%</p>
                        <p><strong>Descripción:</strong> {network_summary.get('description', 'No disponible')}</p>
                    </div>
                    
                    <div class="subsection">
                        <h3>Peticiones DNS</h3>
                        {dns_requests_html}
                    </div>
                    
                    <div class="subsection">
                        <h3>Peticiones HTTP</h3>
                        {http_requests_html}
                    </div>
                    
                    <div class="subsection">
                        <h3>Conexiones de red</h3>
                        {connections_html}
                    </div>
                    
                    <div class="subsection">
                        <h3>Servidores C2 detectados</h3>
                        {c2_servers_html}
                    </div>
                    
                    <div class="subsection">
                        <h3>Exfiltración de datos</h3>
                        {data_exfiltration_html}
                    </div>
                </div>
                """
            
            # Sección de IOCs
            if "iocs" in analysis_results and analysis_results["iocs"]:
                nav_iocs = '<a href="#iocs">Indicadores de Compromiso</a>'
                iocs = analysis_results["iocs"]
                
                # IPs
                ip_iocs_html = "<p>No se detectaron IPs maliciosas.</p>"
                if iocs.get('ips'):
                    ip_iocs_html = "<ul>"
                    for ip in iocs['ips'][:10]:  # Limitar a 10 IPs
                        ip_iocs_html += f"<li><strong>{ip}</strong></li>"
                    ip_iocs_html += "</ul>"
                
                # Dominios
                domain_iocs_html = "<p>No se detectaron dominios maliciosos.</p>"
                if iocs.get('domains'):
                    domain_iocs_html = "<ul>"
                    for domain in iocs['domains'][:10]:  # Limitar a 10 dominios
                        domain_iocs_html += f"<li><strong>{domain}</strong></li>"
                    domain_iocs_html += "</ul>"
                
                # URLs
                url_iocs_html = "<p>No se detectaron URLs maliciosas.</p>"
                if iocs.get('urls'):
                    url_iocs_html = "<ul>"
                    for url in iocs['urls'][:10]:  # Limitar a 10 URLs
                        url_iocs_html += f"<li><strong>{url}</strong></li>"
                    url_iocs_html += "</ul>"
                
                # Archivos
                file_iocs_html = "<p>No se detectaron archivos maliciosos adicionales.</p>"
                if iocs.get('files'):
                    file_iocs_html = "<ul>"
                    for file in iocs['files'][:10]:  # Limitar a 10 archivos
                        if isinstance(file, dict):
                            file_iocs_html += f"<li><strong>{file.get('name', 'Desconocido')}</strong> ({file.get('hash', 'N/A')})</li>"
                        else:
                            file_iocs_html += f"<li><strong>{file}</strong></li>"
                    file_iocs_html += "</ul>"
                
                # Claves de registro
                registry_iocs_html = "<p>No se detectaron claves de registro maliciosas.</p>"
                if iocs.get('registry_keys'):
                    registry_iocs_html = "<ul>"
                    for reg in iocs['registry_keys'][:10]:  # Limitar a 10 claves
                        if isinstance(reg, dict):
                            registry_iocs_html += f"<li><strong>{reg.get('key', 'Desconocido')}</strong></li>"
                        else:
                            registry_iocs_html += f"<li><strong>{reg}</strong></li>"
                    registry_iocs_html += "</ul>"
                
                # Mutexes
                mutex_iocs_html = "<p>No se detectaron mutexes maliciosos.</p>"
                if iocs.get('mutexes'):
                    mutex_iocs_html = "<ul>"
                    for mutex in iocs['mutexes'][:10]:  # Limitar a 10 mutexes
                        if isinstance(mutex, dict):
                            mutex_iocs_html += f"<li><strong>{mutex.get('name', 'Desconocido')}</strong></li>"
                        else:
                            mutex_iocs_html += f"<li><strong>{mutex}</strong></li>"
                    mutex_iocs_html += "</ul>"
                
                iocs_section = f"""
                <div class="section" id="iocs">
                    <h2>Indicadores de Compromiso (IOCs)</h2>
                    <div class="subsection">
                        <h3>Direcciones IP</h3>
                        {ip_iocs_html}
                    </div>
                    
                    <div class="subsection">
                        <h3>Dominios</h3>
                        {domain_iocs_html}
                    </div>
                    
                    <div class="subsection">
                        <h3>URLs</h3>
                        {url_iocs_html}
                    </div>
                    
                    <div class="subsection">
                        <h3>Archivos</h3>
                        {file_iocs_html}
                    </div>
                    
                    <div class="subsection">
                        <h3>Claves de registro</h3>
                        {registry_iocs_html}
                    </div>
                    
                    <div class="subsection">
                        <h3>Mutexes</h3>
                        {mutex_iocs_html}
                    </div>
                </div>
                """
            
            # Sección de MITRE ATT&CK
            if "mitre_attack" in analysis_results and analysis_results["mitre_attack"]:
                nav_mitre = '<a href="#mitre">MITRE ATT&CK</a>'
                mitre = analysis_results["mitre_attack"]
                
                # Técnicas
                techniques_html = "<p>No se identificaron técnicas MITRE ATT&CK.</p>"
                if mitre.get('techniques'):
                    techniques_html = "<table>\n<tr><th>ID</th><th>Técnica</th><th>Táctica</th><th>Descripción</th><th>Confianza</th></tr>"
                    for technique in mitre['techniques']:
                        confidence_class = "low"
                        confidence = technique.get('confidence', 0)
                        if confidence > 80:
                            confidence_class = "high"
                        elif confidence > 50:
                            confidence_class = "medium"
                            
                        techniques_html += f"""<tr>
                            <td><span class="mitre">{technique.get('id', 'T0000')}</span></td>
                            <td>{technique.get('name', 'Desconocida')}</td>
                            <td>{technique.get('tactic', 'Desconocida')}</td>
                            <td>{technique.get('description', 'Sin descripción')}</td>
                            <td><span class="{confidence_class}">{confidence}%</span></td>
                        </tr>"""
                    techniques_html += "</table>"
                
                # Resumen MITRE
                mitre_summary = ""
                if mitre.get('summary'):
                    mitre_summary = f"<p><strong>Resumen:</strong> {mitre.get('summary')}</p>"
                
                mitre_section = f"""
                <div class="section" id="mitre">
                    <h2>Mapeo MITRE ATT&CK</h2>
                    {mitre_summary}
                    <div class="subsection">
                        <h3>Técnicas identificadas</h3>
                        {techniques_html}
                    </div>
                </div>
                """
            
            # Sección de detección por IA
            if "ai_detection" in analysis_results and analysis_results["ai_detection"]:
                nav_ai = '<a href="#ai">Detección por IA</a>'
                ai = analysis_results["ai_detection"]
                
                # Predicciones
                predictions_html = "<p>No hay predicciones disponibles.</p>"
                if ai.get('predictions'):
                    predictions_html = "<table>\n<tr><th>Tipo de malware</th><th>Probabilidad</th></tr>"
                    for pred in ai['predictions']:
                        prob_class = "low"
                        prob = pred.get('probability', 0) * 100
                        if prob > 80:
                            prob_class = "high"
                        elif prob > 50:
                            prob_class = "medium"
                            
                        predictions_html += f"""<tr>
                            <td>{pred.get('malware_type', 'Desconocido')}</td>
                            <td><span class="{prob_class}">{prob:.1f}%</span></td>
                        </tr>"""
                    predictions_html += "</table>"
                
                # Características importantes
                features_html = "<p>No hay características importantes disponibles.</p>"
                if ai.get('important_features'):
                    features_html = "<ul>"
                    for feature in ai['important_features']:
                        features_html += f"<li><strong>{feature.get('name', 'Característica')}</strong>: {feature.get('description', 'Sin descripción')}</li>"
                    features_html += "</ul>"
                
                # Resumen IA
                ai_summary = ai.get('summary', {})
                confidence_class = "low"
                if ai_summary.get('confidence', 0) > 80:
                    confidence_class = "high"
                elif ai_summary.get('confidence', 0) > 50:
                    confidence_class = "medium"
                
                ai_section = f"""
                <div class="section" id="ai">
                    <h2>Detección por Inteligencia Artificial</h2>
                    <div class="subsection">
                        <h3>Resumen de detección por IA</h3>
                        <p><strong>Confianza:</strong> <span class="{confidence_class}">{ai_summary.get('confidence', 0)}%</span></p>
                        <p><strong>Modelo:</strong> {ai.get('model_name', 'Modelo desconocido')}</p>
                        <p><strong>Descripción:</strong> {ai_summary.get('description', 'No disponible')}</p>
                    </div>
                    
                    <div class="subsection">
                        <h3>Predicciones</h3>
                        {predictions_html}
                    </div>
                    
                    <div class="subsection">
                        <h3>Características importantes</h3>
                        {features_html}
                    </div>
                </div>
                """
            
            # Reemplazar variables en la plantilla
            html_report = html_template.format(
                file=analysis_results["file"],
                timestamp=analysis_results["timestamp"],
                risk_level=verdict["risk_level"].upper(),
                risk_class=risk_class_map.get(verdict["risk_level"], ""),
                confidence=verdict["confidence"],
                summary=verdict["summary"],
                family_info=family_info,
                tags_info=tags_info,
                name=file_info["name"],
                size=file_info["size"],
                type=file_info["type"],
                mime=file_info["mime"],
                created=file_info["created"],
                modified=file_info["modified"],
                md5=file_info["hashes"]["md5"],
                sha1=file_info["hashes"]["sha1"],
                sha256=file_info["hashes"]["sha256"],
                ssdeep=file_info["ssdeep"],
                risk_factors=risk_factors_html,
                potential_types=potential_types_html,
                yara_matches=yara_matches_html,
                nav_behavior=nav_behavior,
                nav_memory=nav_memory,
                nav_network=nav_network,
                nav_iocs=nav_iocs,
                nav_mitre=nav_mitre,
                nav_ai=nav_ai,
                behavior_section=behavior_section,
                memory_section=memory_section,
                network_section=network_section,
                iocs_section=iocs_section,
                mitre_section=mitre_section,
                ai_section=ai_section,
                virustotal_section=virustotal_html,
                urls=urls_html or "<li>No se encontraron URLs</li>",
                ips=ips_html or "<li>No se encontraron direcciones IP</li>",
                registry=registry_html or "<li>No se encontraron claves de registro</li>",
                apis=apis_html or "<li>No se encontraron APIs sospechosas</li>"
            )
            
            return html_report
        
        else:  # Formato de texto por defecto
            report = []
            report.append("="*80)
            report.append("INFORME DE ANÁLISIS AVANZADO DE MALWARE - UNITYDEX")
            report.append("="*80)
            report.append("")
            
            # Información general
            report.append("INFORMACIÓN GENERAL")
            report.append("-"*80)
            report.append(f"Archivo: {analysis_results['file']}")
            report.append(f"Fecha de análisis: {analysis_results['timestamp']}")
            report.append(f"Nivel de riesgo: {analysis_results['verdict'].get('risk_level', 'DESCONOCIDO').upper()}")
            report.append(f"Confianza: {analysis_results['verdict'].get('confidence', 0)}%")
            report.append(f"Resumen: {analysis_results['verdict'].get('summary', 'No disponible')}")
            
            # Información ampliada del veredicto
            verdict = analysis_results['verdict']
            if 'family' in verdict and verdict['family']:
                report.append(f"Familia de malware: {verdict['family']}")
            if 'tags' in verdict and verdict['tags']:
                report.append(f"Etiquetas: {', '.join(verdict['tags'])}")
            report.append("")
            
            # Información del archivo
            file_info = analysis_results["file_info"]
            report.append("INFORMACIÓN DEL ARCHIVO")
            report.append("-"*80)
            report.append(f"Nombre: {file_info['name']}")
            report.append(f"Tamaño: {file_info['size']} bytes")
            report.append(f"Tipo: {file_info['type']}")
            report.append(f"MIME: {file_info['mime']}")
            report.append(f"Creado: {file_info['created']}")
            report.append(f"Modificado: {file_info['modified']}")
            report.append(f"MD5: {file_info['hashes']['md5']}")
            report.append(f"SHA1: {file_info['hashes']['sha1']}")
            report.append(f"SHA256: {file_info['hashes']['sha256']}")
            report.append(f"SSDeep: {file_info['ssdeep']}")
            report.append("")
            
            # Factores de riesgo
            heuristic = analysis_results["heuristic_analysis"]
            report.append("FACTORES DE RIESGO")
            report.append("-"*80)
            if heuristic.get("risk_factors"):
                for factor in heuristic["risk_factors"]:
                    report.append(f"- {factor}")
            else:
                report.append("No se encontraron factores de riesgo significativos.")
            report.append("")
            
            # Posible clasificación
            report.append("POSIBLE CLASIFICACIÓN")
            report.append("-"*80)
            if heuristic.get("potential_type"):
                for pt in heuristic["potential_type"]:
                    report.append(f"Tipo: {pt['type']}")
                    report.append(f"Confianza: {pt['confidence']}%")
                    report.append(f"Descripción: {pt['description']}")
                    report.append("")
            else:
                report.append("No se pudo determinar un tipo específico de malware.")
                report.append("")
            
            # Coincidencias YARA
            report.append("COINCIDENCIAS YARA")
            report.append("-"*80)
            if analysis_results.get("yara_matches"):
                for match in analysis_results["yara_matches"]:
                    report.append(f"Regla: {match['rule']}")
                    if match.get("meta"):
                        report.append("Metadatos:")
                        for k, v in match["meta"].items():
                            report.append(f"  {k}: {v}")
                    report.append("")
            else:
                report.append("No se encontraron coincidencias con reglas YARA.")
                report.append("")
            
            # Análisis de comportamiento
            if "behavior_analysis" in analysis_results and analysis_results["behavior_analysis"]:
                behavior = analysis_results["behavior_analysis"]
                report.append("ANÁLISIS DE COMPORTAMIENTO")
                report.append("-"*80)
                
                # Actividad de procesos
                if behavior.get("process_activity"):
                    report.append("Actividad de procesos:")
                    for process in behavior["process_activity"][:5]:  # Limitar a 5 procesos
                        report.append(f"- Proceso: {process.get('process', 'Desconocido')} (PID: {process.get('pid', 'N/A')})")
                        if process.get('command_line'):
                            report.append(f"  Línea de comandos: {process.get('command_line')}")
                    report.append("")
                
                # Actividad de archivos
                if behavior.get("file_activity"):
                    report.append("Actividad de archivos:")
                    for file_act in behavior["file_activity"][:5]:  # Limitar a 5 actividades
                        report.append(f"- {file_act.get('type', 'Acción').capitalize()}: {file_act.get('path', 'Desconocido')}")
                    report.append("")
                
                # Actividad de registro
                if behavior.get("registry_activity"):
                    report.append("Actividad de registro:")
                    for reg_act in behavior["registry_activity"][:5]:  # Limitar a 5 actividades
                        report.append(f"- {reg_act.get('type', 'Acción').capitalize()}: {reg_act.get('key', 'Desconocido')}")
                        if reg_act.get('value') and reg_act.get('data'):
                            report.append(f"  Valor: {reg_act.get('value')} = {reg_act.get('data')}")
                    report.append("")
                
                # Técnicas de evasión
                if behavior.get("evasion_attempts"):
                    report.append("Técnicas de evasión detectadas:")
                    for evasion in behavior["evasion_attempts"]:
                        report.append(f"- {evasion.get('technique', 'Desconocida')}: {evasion.get('description', '')}")
                        if evasion.get('mitre_id'):
                            report.append(f"  MITRE ATT&CK: {evasion.get('mitre_id')}")
                    report.append("")
                
                # Mecanismos de persistencia
                if behavior.get("persistence_mechanisms"):
                    report.append("Mecanismos de persistencia:")
                    for persistence in behavior["persistence_mechanisms"]:
                        report.append(f"- {persistence.get('technique', 'Desconocido')}: {persistence.get('description', '')}")
                        if persistence.get('mitre_id'):
                            report.append(f"  MITRE ATT&CK: {persistence.get('mitre_id')}")
                    report.append("")
                
                # Resumen de comportamiento
                if behavior.get("summary"):
                    report.append("Resumen de comportamiento:")
                    summary = behavior["summary"]
                    report.append(f"- Severidad: {summary.get('severity', 'Desconocida')}")
                    report.append(f"- Confianza: {summary.get('confidence', 0)}")
                    if summary.get('techniques'):
                        report.append(f"- Técnicas: {', '.join(summary.get('techniques', []))}")
                    report.append("")
            
            # Análisis de memoria
            if "memory_analysis" in analysis_results and analysis_results["memory_analysis"]:
                memory = analysis_results["memory_analysis"]
                report.append("ANÁLISIS DE MEMORIA")
                report.append("-"*80)
                
                # Código inyectado
                if memory.get("injected_code"):
                    report.append("Código inyectado detectado:")
                    for injection in memory["injected_code"][:3]:  # Limitar a 3 inyecciones
                        report.append(f"- Proceso: {injection.get('process', 'Desconocido')}")
                        report.append(f"  Región: {injection.get('region', 'Desconocida')} (Protección: {injection.get('protection', 'N/A')})")
                    report.append("")
                
                # Procesos ocultos
                if memory.get("hidden_processes"):
                    report.append("Procesos ocultos:")
                    for process in memory["hidden_processes"]:
                        report.append(f"- PID: {process.get('pid', 'Desconocido')}, Nombre: {process.get('name', 'Desconocido')}")
                        report.append(f"  Técnica: {process.get('technique', 'Desconocida')}")
                    report.append("")
                
                # Funciones hookeadas
                if memory.get("hooked_functions"):
                    report.append("Funciones hookeadas:")
                    for hook in memory["hooked_functions"][:5]:  # Limitar a 5 hooks
                        report.append(f"- {hook.get('module', 'Desconocido')}::{hook.get('function', 'Desconocida')} (Tipo: {hook.get('hook_type', 'Desconocido')})")
                    report.append("")
                
                # Resumen de memoria
                if memory.get("summary"):
                    report.append("Resumen de análisis de memoria:")
                    summary = memory["summary"]
                    report.append(f"- Severidad: {summary.get('severity', 'Desconocida')}")
                    report.append(f"- Confianza: {summary.get('confidence', 0)}")
                    if summary.get('techniques'):
                        report.append(f"- Técnicas: {', '.join(summary.get('techniques', []))}")
                    report.append("")
            
            # Análisis de red
            if "network_analysis" in analysis_results and analysis_results["network_analysis"]:
                network = analysis_results["network_analysis"]
                report.append("ANÁLISIS DE RED")
                report.append("-"*80)
                
                # Peticiones DNS
                if network.get("dns_requests"):
                    report.append("Peticiones DNS:")
                    for dns in network["dns_requests"][:5]:  # Limitar a 5 peticiones
                        report.append(f"- Dominio: {dns.get('domain', 'Desconocido')} → {dns.get('response', 'N/A')}")
                    report.append("")
                
                # Peticiones HTTP
                if network.get("http_requests"):
                    report.append("Peticiones HTTP:")
                    for http in network["http_requests"][:5]:  # Limitar a 5 peticiones
                        report.append(f"- URL: {http.get('url', 'Desconocida')} (Método: {http.get('method', 'GET')})")
                        report.append(f"  User-Agent: {http.get('user_agent', 'Desconocido')}")
                    report.append("")
                
                # Conexiones
                if network.get("connections"):
                    report.append("Conexiones de red:")
                    for conn in network["connections"][:5]:  # Limitar a 5 conexiones
                        report.append(f"- {conn.get('destination_ip', 'Desconocida')}:{conn.get('destination_port', 'N/A')} ({conn.get('protocol', 'tcp')})")
                        if conn.get('bytes_sent') and conn.get('bytes_received'):
                            report.append(f"  Datos: {conn.get('bytes_sent', 0)} bytes enviados, {conn.get('bytes_received', 0)} bytes recibidos")
                    report.append("")
                
                # Servidores C2
                if network.get("c2_servers"):
                    report.append("Posibles servidores de comando y control (C2):")
                    for c2 in network["c2_servers"]:
                        report.append(f"- {c2.get('address', 'Desconocido')} (Confianza: {c2.get('confidence', 'Baja')})")
                        if c2.get('protocol'):
                            report.append(f"  Protocolo: {c2.get('protocol', 'Desconocido')}")
                        if c2.get('evidence'):
                            report.append(f"  Evidencia: {c2.get('evidence', '')}")
                    report.append("")
                
                # Exfiltración de datos
                if network.get("data_exfiltration"):
                    report.append("Posible exfiltración de datos:")
                    for exfil in network["data_exfiltration"]:
                        report.append(f"- Destino: {exfil.get('destination', 'Desconocido')}")
                        report.append(f"  Protocolo: {exfil.get('protocol', 'Desconocido')}, Tamaño: {exfil.get('size', 'Desconocido')} bytes")
                        if exfil.get('evidence'):
                            report.append(f"  Evidencia: {exfil.get('evidence', '')}")
                    report.append("")
            
            # Indicadores de Compromiso (IOCs)
            if "iocs" in analysis_results and analysis_results["iocs"]:
                iocs = analysis_results["iocs"]
                report.append("INDICADORES DE COMPROMISO (IOCs)")
                report.append("-"*80)
                
                # IPs
                if iocs.get("ips"):
                    report.append("Direcciones IP:")
                    for ip in iocs["ips"][:10]:  # Limitar a 10 IPs
                        report.append(f"- {ip}")
                    report.append("")
                
                # Dominios
                if iocs.get("domains"):
                    report.append("Dominios:")
                    for domain in iocs["domains"][:10]:  # Limitar a 10 dominios
                        report.append(f"- {domain}")
                    report.append("")
                
                # URLs
                if iocs.get("urls"):
                    report.append("URLs:")
                    for url in iocs["urls"][:10]:  # Limitar a 10 URLs
                        report.append(f"- {url}")
                    report.append("")
                
                # Archivos
                if iocs.get("files"):
                    report.append("Archivos:")
                    for file in iocs["files"][:10]:  # Limitar a 10 archivos
                        report.append(f"- {file}")
                    report.append("")
                
                # Claves de registro
                if iocs.get("registry"):
                    report.append("Claves de registro:")
                    for reg in iocs["registry"][:10]:  # Limitar a 10 claves
                        if isinstance(reg, dict):
                            report.append(f"- {reg.get('key', 'Desconocida')}: {reg.get('value', '')} = {reg.get('data', '')}")
                        else:
                            report.append(f"- {reg}")
                    report.append("")
                
                # Mutexes
                if iocs.get("mutexes"):
                    report.append("Mutexes:")
                    for mutex in iocs["mutexes"][:10]:  # Limitar a 10 mutexes
                        report.append(f"- {mutex}")
                    report.append("")
            
            # Mapeo a MITRE ATT&CK
            if "mitre_att_ck" in analysis_results and analysis_results["mitre_att_ck"]:
                mitre = analysis_results["mitre_att_ck"]
                report.append("MAPEO A MITRE ATT&CK")
                report.append("-"*80)
                
                for technique in mitre:
                    report.append(f"Técnica: {technique.get('technique_id', 'Desconocida')} - {technique.get('technique_name', 'Desconocida')}")
                    report.append(f"Táctica: {technique.get('tactic', 'Desconocida')}")
                    report.append(f"Descripción: {technique.get('description', '')}")
                    if technique.get('evidence'):
                        report.append(f"Evidencia: {technique.get('evidence', '')}")
                    report.append("")
            
            # Detección por IA
            if "ai_detection" in analysis_results and analysis_results["ai_detection"].get("prediction"):
                ai = analysis_results["ai_detection"]
                report.append("DETECCIÓN MEDIANTE INTELIGENCIA ARTIFICIAL")
                report.append("-"*80)
                
                prediction = ai["prediction"]
                report.append(f"Resultado: {'Malware' if prediction.get('is_malware', False) else 'Limpio'}")
                report.append(f"Confianza: {ai.get('confidence', 0):.2f}")
                
                if prediction.get('is_malware', False):
                    report.append(f"Tipo de malware: {prediction.get('malware_type', 'Desconocido')}")
                    report.append(f"Familia: {prediction.get('family', 'Desconocida')}")
                
                if ai.get("feature_importance"):
                    report.append("\nCaracterísticas más relevantes:")
                    for feature, importance in ai["feature_importance"].items():
                        report.append(f"- {feature}: {importance:.2f}")
                report.append("")
            
            # Resultados de VirusTotal
            if "virustotal" in analysis_results:
                vt = analysis_results["virustotal"]
                report.append("RESULTADOS DE VIRUSTOTAL")
                report.append("-"*80)
                if "error" not in vt:
                    report.append(f"Detecciones: {vt.get('positives', 0)}/{vt.get('total', 0)}")
                    report.append(f"Enlace: {vt.get('permalink', '')}")
                    report.append("")
                    report.append("Principales antivirus:")
                    count = 0
                    for av, result in vt["scans"].items():
                        if count >= 10:  # Limitar a 10 antivirus
                            break
                        if result.get("detected", False):
                            detected = "Sí"
                            av_result = result.get("result", "-")
                            report.append(f"  {av}: {detected} ({av_result})")
                            count += 1
                else:
                    report.append(f"Error: {vt.get('error', 'Desconocido')}")
                report.append("")
            
            # Cadenas interesantes
            strings = analysis_results["static_analysis"].get("strings", {})
            report.append("CADENAS INTERESANTES")
            report.append("-"*80)
            
            report.append("URLs:")
            if strings.get("urls"):
                for url in strings["urls"][:10]:  # Limitar a 10 elementos
                    report.append(f"- {url}")
            else:
                report.append("No se encontraron URLs.")
            report.append("")
            
            report.append("Direcciones IP:")
            if strings.get("ips"):
                for ip in strings["ips"][:10]:
                    report.append(f"- {ip}")
            else:
                report.append("No se encontraron direcciones IP.")
            report.append("")
            
            report.append("Claves de registro:")
            if strings.get("registry"):
                for reg in strings["registry"][:10]:
                    report.append(f"- {reg}")
            else:
                report.append("No se encontraron claves de registro.")
            report.append("")
            
            report.append("APIs sospechosas:")
            if strings.get("apis"):
                for api in strings["apis"][:10]:
                    report.append(f"- {api}")
            else:
                report.append("No se encontraron APIs sospechosas.")
            report.append("")
            
            # Pie del informe
            report.append("="*80)
            report.append("Generado por UnityDex Malware Analyzer v2.0 - Análisis Avanzado")
            report.append("="*80)
            
            return "\n".join(report)

# Función principal para uso desde línea de comandos
def analyze_malware(file_path, options=None):
    """Función principal para análisis de malware"""
    analyzer = MalwareAnalyzer()
    results = analyzer.analyze_file(file_path, options)
    
    # Generar informe en formato de texto por defecto
    report = analyzer.generate_report(results, format=options.get("format", "text"))
    
    # Guardar informe si se especifica un archivo de salida
    if options and "output" in options:
        with open(options["output"], "w", encoding="utf-8") as f:
            f.write(report)
        print(f"Informe guardado en {options['output']}")
    
    return results, report

# Punto de entrada para ejecución directa
if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="Analizador de malware UnityDex")
    parser.add_argument("file", help="Archivo a analizar")
    parser.add_argument("-o", "--output", help="Archivo de salida para el informe")
    parser.add_argument("-f", "--format", choices=["text", "json", "html"], default="text", help="Formato del informe")
    parser.add_argument("--virustotal", action="store_true", help="Consultar VirusTotal")
    
    args = parser.parse_args()
    
    options = {
        "format": args.format,
        "virustotal": args.virustotal
    }
    
    if args.output:
        options["output"] = args.output
    
    _, report = analyze_malware(args.file, options)
    
    # Si no se especifica archivo de salida, imprimir en consola
    if not args.output:
        print(report)